// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: admin.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAdminProblems = `-- name: GetAdminProblems :many
SELECT 
  p.id, p.title, p.description, p.function_name, p.points, p.created_at, p.difficulty, p.tags,
  COALESCE(json_agg(json_build_object('language', s.language, 'code', s.code)), '[]'::json) as solutions
FROM problem p
LEFT JOIN (
    SELECT problem_id, language, code
    FROM problem_solution
    ORDER BY problem_id, id
) s ON p.id = s.problem_id
GROUP BY p.id
`

type GetAdminProblemsRow struct {
	ID           int32             `json:"id"`
	Title        string            `json:"title"`
	Description  pgtype.Text       `json:"description"`
	FunctionName string            `json:"functionName"`
	Points       int32             `json:"points"`
	CreatedAt    pgtype.Timestamp  `json:"createdAt"`
	Difficulty   ProblemDifficulty `json:"difficulty"`
	Tags         []string          `json:"tags"`
	Solutions    interface{}       `json:"solutions"`
}

func (q *Queries) GetAdminProblems(ctx context.Context) ([]GetAdminProblemsRow, error) {
	rows, err := q.db.Query(ctx, getAdminProblems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminProblemsRow
	for rows.Next() {
		var i GetAdminProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FunctionName,
			&i.Points,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Tags,
			&i.Solutions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const validateAdmin = `-- name: ValidateAdmin :one
SELECT admin FROM account WHERE id = $1
`

func (q *Queries) ValidateAdmin(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, validateAdmin, id)
	var admin bool
	err := row.Scan(&admin)
	return admin, err
}
