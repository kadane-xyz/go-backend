// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comments.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one

INSERT INTO comment (user_id, body, solution_id, parent_id)
VALUES ($1::text, $2::text, $3::bigint, $4) 
RETURNING id, solution_id, user_id, body, created_at, votes, parent_id
`

type CreateCommentParams struct {
	UserID     string      `json:"userId"`
	Body       string      `json:"body"`
	SolutionID int64       `json:"solutionId"`
	ParentID   pgtype.Int8 `json:"parentId"`
}

// POST --
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.UserID,
		arg.Body,
		arg.SolutionID,
		arg.ParentID,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.SolutionID,
		&i.UserID,
		&i.Body,
		&i.CreatedAt,
		&i.Votes,
		&i.ParentID,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec

DELETE FROM comment WHERE id = $1 AND user_id = $2
`

type DeleteCommentParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"userId"`
}

// DELETE --
func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.UserID)
	return err
}

const getComment = `-- name: GetComment :one

SELECT 
    c.id, c.solution_id, c.user_id, c.body, c.created_at, c.votes, c.parent_id,
    a.username AS user_username,
    a.avatar_url AS user_avatar_url,
    a.level AS user_level,
    COALESCE(v.vote_count, 0) AS votes_count,
    COALESCE(uv.vote, 'none') AS user_vote
FROM comment c
LEFT JOIN (
    SELECT id, username, avatar_url, level
    FROM account
) a ON c.user_id = a.id
LEFT JOIN (
    SELECT comment_id, COUNT(*) AS vote_count
    FROM comment_user_vote
    GROUP BY comment_id
) v ON c.id = v.comment_id
LEFT JOIN (
    SELECT comment_id, vote
    FROM comment_user_vote
    WHERE user_id = $1::text 
) uv ON c.id = uv.comment_id
WHERE c.id = $2
`

type GetCommentParams struct {
	UserID string `json:"userId"`
	ID     int64  `json:"id"`
}

type GetCommentRow struct {
	ID            int64            `json:"id"`
	SolutionID    int64            `json:"solutionId"`
	UserID        string           `json:"userId"`
	Body          string           `json:"body"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	Votes         pgtype.Int4      `json:"votes"`
	ParentID      pgtype.Int8      `json:"parentId"`
	UserUsername  string           `json:"userUsername"`
	UserAvatarUrl pgtype.Text      `json:"userAvatarUrl"`
	UserLevel     int32            `json:"userLevel"`
	VotesCount    int64            `json:"votesCount"`
	UserVote      VoteType         `json:"userVote"`
}

// GET --
func (q *Queries) GetComment(ctx context.Context, arg GetCommentParams) (GetCommentRow, error) {
	row := q.db.QueryRow(ctx, getComment, arg.UserID, arg.ID)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.SolutionID,
		&i.UserID,
		&i.Body,
		&i.CreatedAt,
		&i.Votes,
		&i.ParentID,
		&i.UserUsername,
		&i.UserAvatarUrl,
		&i.UserLevel,
		&i.VotesCount,
		&i.UserVote,
	)
	return i, err
}

const getCommentById = `-- name: GetCommentById :one
SELECT 1 FROM comment WHERE id = $1
`

func (q *Queries) GetCommentById(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getCommentById, id)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getCommentCount = `-- name: GetCommentCount :one
SELECT COUNT(*) FROM comment WHERE solution_id = $1
`

func (q *Queries) GetCommentCount(ctx context.Context, solutionID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCommentCount, solutionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCommentVote = `-- name: GetCommentVote :one
SELECT vote FROM comment_user_vote
WHERE user_id = $1 AND comment_id = $2
`

type GetCommentVoteParams struct {
	UserID    pgtype.Text `json:"userId"`
	CommentID pgtype.Int8 `json:"commentId"`
}

func (q *Queries) GetCommentVote(ctx context.Context, arg GetCommentVoteParams) (VoteType, error) {
	row := q.db.QueryRow(ctx, getCommentVote, arg.UserID, arg.CommentID)
	var vote VoteType
	err := row.Scan(&vote)
	return vote, err
}

const getCommentVotesBatch = `-- name: GetCommentVotesBatch :many
SELECT comment_id, vote
FROM comment_user_vote
WHERE user_id = $1 AND comment_id = ANY($2::bigint[])
`

type GetCommentVotesBatchParams struct {
	UserID  pgtype.Text `json:"userId"`
	Column2 []int64     `json:"column2"`
}

type GetCommentVotesBatchRow struct {
	CommentID pgtype.Int8 `json:"commentId"`
	Vote      VoteType    `json:"vote"`
}

func (q *Queries) GetCommentVotesBatch(ctx context.Context, arg GetCommentVotesBatchParams) ([]GetCommentVotesBatchRow, error) {
	rows, err := q.db.Query(ctx, getCommentVotesBatch, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentVotesBatchRow
	for rows.Next() {
		var i GetCommentVotesBatchRow
		if err := rows.Scan(&i.CommentID, &i.Vote); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComments = `-- name: GetComments :many
SELECT 
    c.id, c.solution_id, c.user_id, c.body, c.created_at, c.votes, c.parent_id,
    a.username AS user_username,
    a.avatar_url AS user_avatar_url,
    a.level AS user_level,
    COALESCE(v.vote_count, 0) AS votes_count,
    COALESCE(uv.vote, 'none') AS user_vote
FROM comment c
LEFT JOIN (
    SELECT id, username, avatar_url, level
    FROM account
) a ON c.user_id = a.id
LEFT JOIN (
    SELECT comment_id, COUNT(*) AS vote_count
    FROM comment_user_vote
    GROUP BY comment_id
) v ON c.id = v.comment_id
LEFT JOIN (
    SELECT comment_id, vote
    FROM comment_user_vote
    WHERE user_id = $1::text 
) uv ON c.id = uv.comment_id
WHERE c.id = ANY($2::bigint[])
`

type GetCommentsParams struct {
	UserID string  `json:"userId"`
	Ids    []int64 `json:"ids"`
}

type GetCommentsRow struct {
	ID            int64            `json:"id"`
	SolutionID    int64            `json:"solutionId"`
	UserID        string           `json:"userId"`
	Body          string           `json:"body"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	Votes         pgtype.Int4      `json:"votes"`
	ParentID      pgtype.Int8      `json:"parentId"`
	UserUsername  string           `json:"userUsername"`
	UserAvatarUrl pgtype.Text      `json:"userAvatarUrl"`
	UserLevel     int32            `json:"userLevel"`
	VotesCount    int64            `json:"votesCount"`
	UserVote      VoteType         `json:"userVote"`
}

func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]GetCommentsRow, error) {
	rows, err := q.db.Query(ctx, getComments, arg.UserID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsRow
	for rows.Next() {
		var i GetCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.SolutionID,
			&i.UserID,
			&i.Body,
			&i.CreatedAt,
			&i.Votes,
			&i.ParentID,
			&i.UserUsername,
			&i.UserAvatarUrl,
			&i.UserLevel,
			&i.VotesCount,
			&i.UserVote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsSorted = `-- name: GetCommentsSorted :many
SELECT 
    c.id, c.solution_id, c.user_id, c.body, c.created_at, c.votes, c.parent_id,
    a.username AS user_username,
    a.avatar_url AS user_avatar_url,
    a.level AS user_level,
    COALESCE(v.vote_count, 0) AS votes_count,
    COALESCE(uv.vote, 'none') AS user_vote
FROM comment c
LEFT JOIN (
    SELECT id, username, avatar_url, level
    FROM account
) a ON c.user_id = a.id
LEFT JOIN (
    SELECT comment_id, COUNT(*) AS vote_count
    FROM comment_user_vote
    GROUP BY comment_id
) v ON c.id = v.comment_id
LEFT JOIN (
    SELECT comment_id, vote
    FROM comment_user_vote
    WHERE user_id = $1::text 
) uv ON c.id = uv.comment_id
WHERE c.solution_id = $2
ORDER BY 
    (CASE WHEN $3 = 'id'         AND $4 = 'ASC'  THEN c.id          END) ASC,
    (CASE WHEN $3 = 'id'         AND $4 = 'DESC' THEN c.id          END) DESC,
    (CASE WHEN $3 = 'created_at' AND $4 = 'ASC'  THEN c.created_at   END) ASC,
    (CASE WHEN $3 = 'created_at' AND $4 = 'DESC' THEN c.created_at   END) DESC,
    (CASE WHEN $3 = 'username'   AND $4 = 'ASC'  THEN a.username     END) ASC,
    (CASE WHEN $3 = 'username'   AND $4 = 'DESC' THEN a.username     END) DESC,
    (CASE WHEN $3 = 'votes'      AND $4 = 'ASC'  THEN v.vote_count   END) ASC,
    (CASE WHEN $3 = 'votes'      AND $4 = 'DESC' THEN v.vote_count   END) DESC,
    c.id DESC
`

type GetCommentsSortedParams struct {
	UserID        string      `json:"userId"`
	SolutionID    int64       `json:"solutionId"`
	Sort          interface{} `json:"sort"`
	SortDirection interface{} `json:"sortDirection"`
}

type GetCommentsSortedRow struct {
	ID            int64            `json:"id"`
	SolutionID    int64            `json:"solutionId"`
	UserID        string           `json:"userId"`
	Body          string           `json:"body"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	Votes         pgtype.Int4      `json:"votes"`
	ParentID      pgtype.Int8      `json:"parentId"`
	UserUsername  string           `json:"userUsername"`
	UserAvatarUrl pgtype.Text      `json:"userAvatarUrl"`
	UserLevel     int32            `json:"userLevel"`
	VotesCount    int64            `json:"votesCount"`
	UserVote      VoteType         `json:"userVote"`
}

func (q *Queries) GetCommentsSorted(ctx context.Context, arg GetCommentsSortedParams) ([]GetCommentsSortedRow, error) {
	rows, err := q.db.Query(ctx, getCommentsSorted,
		arg.UserID,
		arg.SolutionID,
		arg.Sort,
		arg.SortDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsSortedRow
	for rows.Next() {
		var i GetCommentsSortedRow
		if err := rows.Scan(
			&i.ID,
			&i.SolutionID,
			&i.UserID,
			&i.Body,
			&i.CreatedAt,
			&i.Votes,
			&i.ParentID,
			&i.UserUsername,
			&i.UserAvatarUrl,
			&i.UserLevel,
			&i.VotesCount,
			&i.UserVote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :one

UPDATE comment
SET body = $1
WHERE id = $2
AND user_id = $3
RETURNING id, solution_id, user_id, body, created_at, votes, parent_id
`

type UpdateCommentParams struct {
	Body   string `json:"body"`
	ID     int64  `json:"id"`
	UserID string `json:"userId"`
}

// PUT --
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.Body, arg.ID, arg.UserID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.SolutionID,
		&i.UserID,
		&i.Body,
		&i.CreatedAt,
		&i.Votes,
		&i.ParentID,
	)
	return i, err
}

const voteComment = `-- name: VoteComment :exec

SELECT set_comment_vote($1::text, $2::bigint, $3::vote_type)
`

type VoteCommentParams struct {
	UserID    string   `json:"userId"`
	CommentID int64    `json:"commentId"`
	Vote      VoteType `json:"vote"`
}

// PATCH
func (q *Queries) VoteComment(ctx context.Context, arg VoteCommentParams) error {
	_, err := q.db.Exec(ctx, voteComment, arg.UserID, arg.CommentID, arg.Vote)
	return err
}
