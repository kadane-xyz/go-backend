// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: friends.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptFriendRequest = `-- name: AcceptFriendRequest :exec
UPDATE friendship
SET status = 'accepted', accepted_at = NOW()
WHERE ((user_id_1 = $1 AND user_id_2 = (SELECT a.id FROM account a WHERE a.username = $2))
   OR (user_id_2 = $1 AND user_id_1 = (SELECT a.id FROM account a WHERE a.username = $2)))
AND status = 'pending'
`

type AcceptFriendRequestParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

func (q *Queries) AcceptFriendRequest(ctx context.Context, arg AcceptFriendRequestParams) error {
	_, err := q.db.Exec(ctx, acceptFriendRequest, arg.UserID, arg.FriendName)
	return err
}

const blockFriend = `-- name: BlockFriend :exec
UPDATE friendship
SET status = 'blocked', accepted_at = NULL
WHERE ((user_id_1 = $1 AND user_id_2 = (SELECT a.id FROM account a WHERE a.username = $2))
   OR (user_id_2 = $1 AND user_id_1 = (SELECT a.id FROM account a WHERE a.username = $2)))
AND status IN ('pending', 'accepted')
`

type BlockFriendParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

func (q *Queries) BlockFriend(ctx context.Context, arg BlockFriendParams) error {
	_, err := q.db.Exec(ctx, blockFriend, arg.UserID, arg.FriendName)
	return err
}

const createFriendRequest = `-- name: CreateFriendRequest :exec
INSERT INTO friendship (user_id_1, user_id_2, initiator_id, status)
SELECT 
    CASE WHEN $1 < a.id THEN $1 ELSE a.id END,
    CASE WHEN $1 < a.id THEN a.id ELSE $1 END,
    $1::text,
    'pending'
FROM account a
WHERE a.username = $2
  AND a.username != (SELECT username FROM account WHERE id = $1)
  AND NOT EXISTS (
    SELECT 1 
    FROM friendship f 
    WHERE (f.user_id_1 = LEAST($1, a.id) 
      AND f.user_id_2 = GREATEST($1, a.id))
  )
ON CONFLICT (user_id_1, user_id_2) DO NOTHING
`

type CreateFriendRequestParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

func (q *Queries) CreateFriendRequest(ctx context.Context, arg CreateFriendRequestParams) error {
	_, err := q.db.Exec(ctx, createFriendRequest, arg.UserID, arg.FriendName)
	return err
}

const deleteFriendship = `-- name: DeleteFriendship :exec
WITH friend_id AS (
    SELECT id
    FROM account
    WHERE username = $2
      AND id != $1
)
DELETE FROM friendship
WHERE (user_id_1 = $1::text AND user_id_2 IN (SELECT id FROM friend_id))
   OR (user_id_2 = $1::text AND user_id_1 IN (SELECT id FROM friend_id))
`

type DeleteFriendshipParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

func (q *Queries) DeleteFriendship(ctx context.Context, arg DeleteFriendshipParams) error {
	_, err := q.db.Exec(ctx, deleteFriendship, arg.UserID, arg.FriendName)
	return err
}

const getFriendRequestStatus = `-- name: GetFriendRequestStatus :one

SELECT status
FROM friendship
WHERE (user_id_1 = $1 AND user_id_2 = (SELECT a.id FROM account a WHERE a.username = $2))
   OR (user_id_2 = $1 AND user_id_1 = (SELECT a.id FROM account a WHERE a.username = $2))
`

type GetFriendRequestStatusParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

// Friend requests
func (q *Queries) GetFriendRequestStatus(ctx context.Context, arg GetFriendRequestStatusParams) (FriendshipStatus, error) {
	row := q.db.QueryRow(ctx, getFriendRequestStatus, arg.UserID, arg.FriendName)
	var status FriendshipStatus
	err := row.Scan(&status)
	return status, err
}

const getFriendRequestsReceived = `-- name: GetFriendRequestsReceived :many
SELECT
    friend.id                         AS friend_id,
    friend.username                   AS friend_username,
    COALESCE(friend.avatar_url, '')::text AS avatar_url,
    COALESCE(friend.level, 0)::int        AS level,
    COALESCE(aa.location, '')::text      AS location,
    f.created_at
FROM friendship f
JOIN account friend
  ON friend.id = CASE
      WHEN f.user_id_1 = $1::text THEN f.user_id_2
      ELSE f.user_id_1
    END
LEFT JOIN account_attribute aa
  ON friend.id = aa.id
WHERE f.status = 'pending'
  AND (f.user_id_1 = $1::text OR f.user_id_2 = $1::text)
  AND f.initiator_id != $1::text
`

type GetFriendRequestsReceivedRow struct {
	FriendID       string             `json:"friendId"`
	FriendUsername string             `json:"friendUsername"`
	AvatarUrl      string             `json:"avatarUrl"`
	Level          int32              `json:"level"`
	Location       string             `json:"location"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
}

func (q *Queries) GetFriendRequestsReceived(ctx context.Context, userID string) ([]GetFriendRequestsReceivedRow, error) {
	rows, err := q.db.Query(ctx, getFriendRequestsReceived, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendRequestsReceivedRow
	for rows.Next() {
		var i GetFriendRequestsReceivedRow
		if err := rows.Scan(
			&i.FriendID,
			&i.FriendUsername,
			&i.AvatarUrl,
			&i.Level,
			&i.Location,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendRequestsSent = `-- name: GetFriendRequestsSent :many
SELECT 
    a.id AS friend_id,
    a.username AS friend_username,
    COALESCE(a.avatar_url, '')::text AS avatar_url,
    COALESCE(a.level, 0)::int AS level,
    COALESCE(aa.location, '')::text AS location,
    f.created_at
FROM friendship f
JOIN account a ON a.id = CASE 
    WHEN f.user_id_1 = $1::text THEN f.user_id_2
    WHEN f.user_id_2 = $1::text THEN f.user_id_1
    ELSE f.user_id_2  -- fallback, though this case shouldn't occur
END
LEFT JOIN account_attribute aa ON a.id = aa.id
WHERE f.initiator_id = $1::text
AND f.status = 'pending'
`

type GetFriendRequestsSentRow struct {
	FriendID       string             `json:"friendId"`
	FriendUsername string             `json:"friendUsername"`
	AvatarUrl      string             `json:"avatarUrl"`
	Level          int32              `json:"level"`
	Location       string             `json:"location"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
}

func (q *Queries) GetFriendRequestsSent(ctx context.Context, userID string) ([]GetFriendRequestsSentRow, error) {
	rows, err := q.db.Query(ctx, getFriendRequestsSent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendRequestsSentRow
	for rows.Next() {
		var i GetFriendRequestsSentRow
		if err := rows.Scan(
			&i.FriendID,
			&i.FriendUsername,
			&i.AvatarUrl,
			&i.Level,
			&i.Location,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriends = `-- name: GetFriends :many
SELECT 
    a.id as friend_id,
    a.username as friend_username,
    COALESCE(a.avatar_url, '')::text as avatar_url,
    COALESCE(a.level, 0)::int as level,
    COALESCE(aa.location, '')::text as location,
    f.accepted_at
FROM friendship f
JOIN account a ON (
    CASE 
        WHEN f.user_id_1 = $1 THEN a.id = f.user_id_2
        ELSE a.id = f.user_id_1
    END
)
LEFT JOIN account_attribute aa ON a.id = aa.id
WHERE (f.user_id_1 = $1 OR f.user_id_2 = $1) AND f.status = 'accepted'
`

type GetFriendsRow struct {
	FriendID       string             `json:"friendId"`
	FriendUsername string             `json:"friendUsername"`
	AvatarUrl      string             `json:"avatarUrl"`
	Level          int32              `json:"level"`
	Location       string             `json:"location"`
	AcceptedAt     pgtype.Timestamptz `json:"acceptedAt"`
}

func (q *Queries) GetFriends(ctx context.Context, userID string) ([]GetFriendsRow, error) {
	rows, err := q.db.Query(ctx, getFriends, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsRow
	for rows.Next() {
		var i GetFriendsRow
		if err := rows.Scan(
			&i.FriendID,
			&i.FriendUsername,
			&i.AvatarUrl,
			&i.Level,
			&i.Location,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsByUsername = `-- name: GetFriendsByUsername :many
WITH user_info AS (
    SELECT a.id, a.username
    FROM account a
    WHERE a.username = $1
)
SELECT 
    a.id as friend_id,
    a.username as friend_username,
    COALESCE(a.avatar_url, '')::text as avatar_url,
    COALESCE(a.level, 0)::int as level,
    COALESCE(aa.location, '')::text as location,
    f.accepted_at
FROM friendship f
JOIN user_info u ON (f.user_id_1 = u.id OR f.user_id_2 = u.id)
JOIN account a ON (
    CASE 
        WHEN f.user_id_1 = u.id THEN a.id = f.user_id_2
        ELSE a.id = f.user_id_1
    END
)
LEFT JOIN account_attribute aa ON a.id = aa.id
WHERE f.status = 'accepted'
`

type GetFriendsByUsernameRow struct {
	FriendID       string             `json:"friendId"`
	FriendUsername string             `json:"friendUsername"`
	AvatarUrl      string             `json:"avatarUrl"`
	Level          int32              `json:"level"`
	Location       string             `json:"location"`
	AcceptedAt     pgtype.Timestamptz `json:"acceptedAt"`
}

func (q *Queries) GetFriendsByUsername(ctx context.Context, friendName string) ([]GetFriendsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getFriendsByUsername, friendName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsByUsernameRow
	for rows.Next() {
		var i GetFriendsByUsernameRow
		if err := rows.Scan(
			&i.FriendID,
			&i.FriendUsername,
			&i.AvatarUrl,
			&i.Level,
			&i.Location,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unblockFriend = `-- name: UnblockFriend :exec
UPDATE friendship
SET status = 'accepted', accepted_at = NOW()
WHERE ((user_id_1 = $1 AND user_id_2 = (SELECT a.id FROM account a WHERE a.username = $2))
   OR (user_id_2 = $1 AND user_id_1 = (SELECT a.id FROM account a WHERE a.username = $2)))
AND status = 'blocked'
`

type UnblockFriendParams struct {
	UserID     string `json:"userId"`
	FriendName string `json:"friendName"`
}

func (q *Queries) UnblockFriend(ctx context.Context, arg UnblockFriendParams) error {
	_, err := q.db.Exec(ctx, unblockFriend, arg.UserID, arg.FriendName)
	return err
}
