// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package sql

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AccountPlan string

const (
	AccountPlanFree AccountPlan = "free"
	AccountPlanPlus AccountPlan = "plus"
	AccountPlanPro  AccountPlan = "pro"
)

func (e *AccountPlan) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccountPlan(s)
	case string:
		*e = AccountPlan(s)
	default:
		return fmt.Errorf("unsupported scan type for AccountPlan: %T", src)
	}
	return nil
}

type NullAccountPlan struct {
	AccountPlan AccountPlan `json:"accountPlan"`
	Valid       bool        `json:"valid"` // Valid is true if AccountPlan is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountPlan) Scan(value interface{}) error {
	if value == nil {
		ns.AccountPlan, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccountPlan.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountPlan) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccountPlan), nil
}

type FriendshipStatus string

const (
	FriendshipStatusPending  FriendshipStatus = "pending"
	FriendshipStatusAccepted FriendshipStatus = "accepted"
	FriendshipStatusBlocked  FriendshipStatus = "blocked"
)

func (e *FriendshipStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FriendshipStatus(s)
	case string:
		*e = FriendshipStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FriendshipStatus: %T", src)
	}
	return nil
}

type NullFriendshipStatus struct {
	FriendshipStatus FriendshipStatus `json:"friendshipStatus"`
	Valid            bool             `json:"valid"` // Valid is true if FriendshipStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFriendshipStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FriendshipStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FriendshipStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFriendshipStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FriendshipStatus), nil
}

type ProblemDifficulty string

const (
	ProblemDifficultyEasy   ProblemDifficulty = "easy"
	ProblemDifficultyMedium ProblemDifficulty = "medium"
	ProblemDifficultyHard   ProblemDifficulty = "hard"
)

func (e *ProblemDifficulty) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProblemDifficulty(s)
	case string:
		*e = ProblemDifficulty(s)
	default:
		return fmt.Errorf("unsupported scan type for ProblemDifficulty: %T", src)
	}
	return nil
}

type NullProblemDifficulty struct {
	ProblemDifficulty ProblemDifficulty `json:"problemDifficulty"`
	Valid             bool              `json:"valid"` // Valid is true if ProblemDifficulty is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProblemDifficulty) Scan(value interface{}) error {
	if value == nil {
		ns.ProblemDifficulty, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProblemDifficulty.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProblemDifficulty) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProblemDifficulty), nil
}

type ProblemLanguage string

const (
	ProblemLanguageCpp        ProblemLanguage = "cpp"
	ProblemLanguageGo         ProblemLanguage = "go"
	ProblemLanguageJava       ProblemLanguage = "java"
	ProblemLanguageJavascript ProblemLanguage = "javascript"
	ProblemLanguagePython     ProblemLanguage = "python"
	ProblemLanguageTypescript ProblemLanguage = "typescript"
)

func (e *ProblemLanguage) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProblemLanguage(s)
	case string:
		*e = ProblemLanguage(s)
	default:
		return fmt.Errorf("unsupported scan type for ProblemLanguage: %T", src)
	}
	return nil
}

type NullProblemLanguage struct {
	ProblemLanguage ProblemLanguage `json:"problemLanguage"`
	Valid           bool            `json:"valid"` // Valid is true if ProblemLanguage is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProblemLanguage) Scan(value interface{}) error {
	if value == nil {
		ns.ProblemLanguage, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProblemLanguage.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProblemLanguage) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProblemLanguage), nil
}

type ProblemSort string

const (
	ProblemSortAlpha ProblemSort = "alpha"
	ProblemSortIndex ProblemSort = "index"
)

func (e *ProblemSort) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProblemSort(s)
	case string:
		*e = ProblemSort(s)
	default:
		return fmt.Errorf("unsupported scan type for ProblemSort: %T", src)
	}
	return nil
}

type NullProblemSort struct {
	ProblemSort ProblemSort `json:"problemSort"`
	Valid       bool        `json:"valid"` // Valid is true if ProblemSort is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProblemSort) Scan(value interface{}) error {
	if value == nil {
		ns.ProblemSort, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProblemSort.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProblemSort) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProblemSort), nil
}

type ProblemTestCaseType string

const (
	ProblemTestCaseTypeInt     ProblemTestCaseType = "int"
	ProblemTestCaseTypeValue1  ProblemTestCaseType = "int[]"
	ProblemTestCaseTypeString  ProblemTestCaseType = "string"
	ProblemTestCaseTypeValue3  ProblemTestCaseType = "string[]"
	ProblemTestCaseTypeFloat   ProblemTestCaseType = "float"
	ProblemTestCaseTypeValue5  ProblemTestCaseType = "float[]"
	ProblemTestCaseTypeDouble  ProblemTestCaseType = "double"
	ProblemTestCaseTypeValue7  ProblemTestCaseType = "double[]"
	ProblemTestCaseTypeBoolean ProblemTestCaseType = "boolean"
	ProblemTestCaseTypeValue9  ProblemTestCaseType = "boolean[]"
	ProblemTestCaseTypeNull    ProblemTestCaseType = "null"
)

func (e *ProblemTestCaseType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProblemTestCaseType(s)
	case string:
		*e = ProblemTestCaseType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProblemTestCaseType: %T", src)
	}
	return nil
}

type NullProblemTestCaseType struct {
	ProblemTestCaseType ProblemTestCaseType `json:"problemTestCaseType"`
	Valid               bool                `json:"valid"` // Valid is true if ProblemTestCaseType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProblemTestCaseType) Scan(value interface{}) error {
	if value == nil {
		ns.ProblemTestCaseType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProblemTestCaseType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProblemTestCaseType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProblemTestCaseType), nil
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "asc"
	SortDirectionDesc SortDirection = "desc"
)

func (e *SortDirection) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SortDirection(s)
	case string:
		*e = SortDirection(s)
	default:
		return fmt.Errorf("unsupported scan type for SortDirection: %T", src)
	}
	return nil
}

type NullSortDirection struct {
	SortDirection SortDirection `json:"sortDirection"`
	Valid         bool          `json:"valid"` // Valid is true if SortDirection is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSortDirection) Scan(value interface{}) error {
	if value == nil {
		ns.SortDirection, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SortDirection.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSortDirection) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SortDirection), nil
}

type SubmissionStatus string

const (
	SubmissionStatusInQueue             SubmissionStatus = "In Queue"
	SubmissionStatusProcessing          SubmissionStatus = "Processing"
	SubmissionStatusAccepted            SubmissionStatus = "Accepted"
	SubmissionStatusWrongAnswer         SubmissionStatus = "Wrong Answer"
	SubmissionStatusTimeLimitExceeded   SubmissionStatus = "Time Limit Exceeded"
	SubmissionStatusCompilationError    SubmissionStatus = "Compilation Error"
	SubmissionStatusRuntimeErrorSIGSEGV SubmissionStatus = "Runtime Error (SIGSEGV)"
	SubmissionStatusRuntimeErrorSIGXFSZ SubmissionStatus = "Runtime Error (SIGXFSZ)"
	SubmissionStatusRuntimeErrorSIGFPE  SubmissionStatus = "Runtime Error (SIGFPE)"
	SubmissionStatusRuntimeErrorSIGABRT SubmissionStatus = "Runtime Error (SIGABRT)"
	SubmissionStatusRuntimeErrorNZEC    SubmissionStatus = "Runtime Error (NZEC)"
	SubmissionStatusRuntimeErrorOther   SubmissionStatus = "Runtime Error (Other)"
	SubmissionStatusInternalError       SubmissionStatus = "Internal Error"
	SubmissionStatusExecFormatError     SubmissionStatus = "Exec Format Error"
)

func (e *SubmissionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubmissionStatus(s)
	case string:
		*e = SubmissionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubmissionStatus: %T", src)
	}
	return nil
}

type NullSubmissionStatus struct {
	SubmissionStatus SubmissionStatus `json:"submissionStatus"`
	Valid            bool             `json:"valid"` // Valid is true if SubmissionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubmissionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubmissionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubmissionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubmissionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubmissionStatus), nil
}

type Visibility string

const (
	VisibilityPublic  Visibility = "public"
	VisibilityPrivate Visibility = "private"
)

func (e *Visibility) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Visibility(s)
	case string:
		*e = Visibility(s)
	default:
		return fmt.Errorf("unsupported scan type for Visibility: %T", src)
	}
	return nil
}

type NullVisibility struct {
	Visibility Visibility `json:"visibility"`
	Valid      bool       `json:"valid"` // Valid is true if Visibility is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVisibility) Scan(value interface{}) error {
	if value == nil {
		ns.Visibility, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Visibility.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVisibility) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Visibility), nil
}

type VoteType string

const (
	VoteTypeUp   VoteType = "up"
	VoteTypeDown VoteType = "down"
	VoteTypeNone VoteType = "none"
)

func (e *VoteType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VoteType(s)
	case string:
		*e = VoteType(s)
	default:
		return fmt.Errorf("unsupported scan type for VoteType: %T", src)
	}
	return nil
}

type NullVoteType struct {
	VoteType VoteType `json:"voteType"`
	Valid    bool     `json:"valid"` // Valid is true if VoteType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVoteType) Scan(value interface{}) error {
	if value == nil {
		ns.VoteType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VoteType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVoteType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VoteType), nil
}

type Account struct {
	ID        string           `json:"id"`
	Username  string           `json:"username"`
	Email     string           `json:"email"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	AvatarUrl pgtype.Text      `json:"avatarUrl"`
	Admin     bool             `json:"admin"`
	Plan      AccountPlan      `json:"plan"`
	Level     int32            `json:"level"`
}

type AccountAttribute struct {
	ID           string      `json:"id"`
	Bio          pgtype.Text `json:"bio"`
	ContactEmail pgtype.Text `json:"contactEmail"`
	Location     pgtype.Text `json:"location"`
	RealName     pgtype.Text `json:"realName"`
	GithubUrl    pgtype.Text `json:"githubUrl"`
	LinkedinUrl  pgtype.Text `json:"linkedinUrl"`
	FacebookUrl  pgtype.Text `json:"facebookUrl"`
	InstagramUrl pgtype.Text `json:"instagramUrl"`
	TwitterUrl   pgtype.Text `json:"twitterUrl"`
	School       pgtype.Text `json:"school"`
	WebsiteUrl   pgtype.Text `json:"websiteUrl"`
}

type AccountGameStat struct {
	ID     int64       `json:"id"`
	UserID pgtype.Text `json:"userId"`
	Wins   pgtype.Int4 `json:"wins"`
	Losses pgtype.Int4 `json:"losses"`
	Elo    pgtype.Int4 `json:"elo"`
}

type AccountSolvedProblem struct {
	ID        int64            `json:"id"`
	UserID    pgtype.Text      `json:"userId"`
	ProblemID pgtype.Int8      `json:"problemId"`
	SolvedAt  pgtype.Timestamp `json:"solvedAt"`
}

type Comment struct {
	ID         int64            `json:"id"`
	SolutionID int64            `json:"solutionId"`
	UserID     string           `json:"userId"`
	Body       string           `json:"body"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	Votes      pgtype.Int4      `json:"votes"`
	ParentID   pgtype.Int8      `json:"parentId"`
}

type CommentUserVote struct {
	ID        int64       `json:"id"`
	CommentID pgtype.Int8 `json:"commentId"`
	UserID    pgtype.Text `json:"userId"`
	Vote      VoteType    `json:"vote"`
}

type Friendship struct {
	UserID1     string             `json:"userId1"`
	UserID2     string             `json:"userId2"`
	InitiatorID pgtype.Text        `json:"initiatorId"`
	Status      FriendshipStatus   `json:"status"`
	AcceptedAt  pgtype.Timestamptz `json:"acceptedAt"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
}

type Problem struct {
	ID           int32             `json:"id"`
	Title        string            `json:"title"`
	Description  pgtype.Text       `json:"description"`
	FunctionName string            `json:"functionName"`
	Points       int32             `json:"points"`
	CreatedAt    pgtype.Timestamp  `json:"createdAt"`
	Difficulty   ProblemDifficulty `json:"difficulty"`
	Tags         []string          `json:"tags"`
}

type ProblemCode struct {
	ID        int32            `json:"id"`
	ProblemID pgtype.Int4      `json:"problemId"`
	Language  ProblemLanguage  `json:"language"`
	Code      string           `json:"code"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
}

type ProblemHint struct {
	ID          int32            `json:"id"`
	ProblemID   pgtype.Int4      `json:"problemId"`
	Description string           `json:"description"`
	Answer      string           `json:"answer"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
}

type ProblemSolution struct {
	ID        int32            `json:"id"`
	ProblemID pgtype.Int4      `json:"problemId"`
	Language  ProblemLanguage  `json:"language"`
	Code      string           `json:"code"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
}

type ProblemTestCase struct {
	ID          int32            `json:"id"`
	ProblemID   pgtype.Int4      `json:"problemId"`
	Description string           `json:"description"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	Visibility  Visibility       `json:"visibility"`
}

type ProblemTestCaseInput struct {
	ID                int32               `json:"id"`
	ProblemTestCaseID pgtype.Int4         `json:"problemTestCaseId"`
	Name              string              `json:"name"`
	Type              ProblemTestCaseType `json:"type"`
	Value             string              `json:"value"`
	CreatedAt         pgtype.Timestamp    `json:"createdAt"`
}

type ProblemTestCaseOutput struct {
	ID                int32            `json:"id"`
	ProblemTestCaseID pgtype.Int4      `json:"problemTestCaseId"`
	Value             string           `json:"value"`
	CreatedAt         pgtype.Timestamp `json:"createdAt"`
}

type Solution struct {
	ID        int64            `json:"id"`
	UserID    pgtype.Text      `json:"userId"`
	ProblemID pgtype.Int8      `json:"problemId"`
	Title     string           `json:"title"`
	Body      string           `json:"body"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Votes     pgtype.Int4      `json:"votes"`
	Tags      []string         `json:"tags"`
}

type SolutionUserVote struct {
	ID         int64    `json:"id"`
	SolutionID int64    `json:"solutionId"`
	UserID     string   `json:"userId"`
	Vote       VoteType `json:"vote"`
}

type StarredProblem struct {
	ID        int32            `json:"id"`
	UserID    string           `json:"userId"`
	ProblemID int32            `json:"problemId"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
}

type StarredSolution struct {
	ID         int32            `json:"id"`
	UserID     string           `json:"userId"`
	SolutionID int32            `json:"solutionId"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
}

type StarredSubmission struct {
	ID           int32            `json:"id"`
	UserID       string           `json:"userId"`
	SubmissionID pgtype.UUID      `json:"submissionId"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
}

type Submission struct {
	ID              pgtype.UUID      `json:"id"`
	Stdout          pgtype.Text      `json:"stdout"`
	Time            pgtype.Text      `json:"time"`
	Memory          pgtype.Int4      `json:"memory"`
	Stderr          pgtype.Text      `json:"stderr"`
	CompileOutput   pgtype.Text      `json:"compileOutput"`
	Message         pgtype.Text      `json:"message"`
	Status          SubmissionStatus `json:"status"`
	LanguageID      int32            `json:"languageId"`
	LanguageName    string           `json:"languageName"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	AccountID       string           `json:"accountId"`
	SubmittedCode   string           `json:"submittedCode"`
	SubmittedStdin  pgtype.Text      `json:"submittedStdin"`
	FailedTestCase  []byte           `json:"failedTestCase"`
	PassedTestCases pgtype.Int4      `json:"passedTestCases"`
	TotalTestCases  pgtype.Int4      `json:"totalTestCases"`
	ProblemID       int32            `json:"problemId"`
}
