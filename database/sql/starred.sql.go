// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: starred.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getStarredProblemByProblemID = `-- name: GetStarredProblemByProblemID :one
SELECT COUNT(*) > 0 
FROM starred_problem 
WHERE starred_problem.user_id = $1 
  AND problem_id = $2
`

type GetStarredProblemByProblemIDParams struct {
	UserID    string `json:"userId"`
	ProblemID int32  `json:"problemId"`
}

func (q *Queries) GetStarredProblemByProblemID(ctx context.Context, arg GetStarredProblemByProblemIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, getStarredProblemByProblemID, arg.UserID, arg.ProblemID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getStarredProblems = `-- name: GetStarredProblems :many
SELECT 
    p.id, p.title, p.description, p.function_name, p.points, p.created_at, p.difficulty, p.tags,
    EXISTS (
        SELECT 1 
        FROM starred_problem sp
        WHERE sp.user_id = $1 
          AND sp.problem_id = p.id
    ) AS starred
FROM problem p
`

type GetStarredProblemsRow struct {
	ID           int32             `json:"id"`
	Title        string            `json:"title"`
	Description  pgtype.Text       `json:"description"`
	FunctionName string            `json:"functionName"`
	Points       int32             `json:"points"`
	CreatedAt    pgtype.Timestamp  `json:"createdAt"`
	Difficulty   ProblemDifficulty `json:"difficulty"`
	Tags         []string          `json:"tags"`
	Starred      bool              `json:"starred"`
}

func (q *Queries) GetStarredProblems(ctx context.Context, userID string) ([]GetStarredProblemsRow, error) {
	rows, err := q.db.Query(ctx, getStarredProblems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStarredProblemsRow
	for rows.Next() {
		var i GetStarredProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FunctionName,
			&i.Points,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Tags,
			&i.Starred,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredProblemsByProblemID = `-- name: GetStarredProblemsByProblemID :many
SELECT id, user_id, problem_id, created_at FROM starred_problem WHERE user_id = $1 AND problem_id = $2
`

type GetStarredProblemsByProblemIDParams struct {
	UserID    string `json:"userId"`
	ProblemID int32  `json:"problemId"`
}

func (q *Queries) GetStarredProblemsByProblemID(ctx context.Context, arg GetStarredProblemsByProblemIDParams) ([]StarredProblem, error) {
	rows, err := q.db.Query(ctx, getStarredProblemsByProblemID, arg.UserID, arg.ProblemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StarredProblem
	for rows.Next() {
		var i StarredProblem
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredSolutionByProblemID = `-- name: GetStarredSolutionByProblemID :one
SELECT COUNT(*) > 0 FROM starred_solution WHERE user_id = $1 AND solution_id = $2
`

type GetStarredSolutionByProblemIDParams struct {
	UserID     string `json:"userId"`
	SolutionID int32  `json:"solutionId"`
}

func (q *Queries) GetStarredSolutionByProblemID(ctx context.Context, arg GetStarredSolutionByProblemIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, getStarredSolutionByProblemID, arg.UserID, arg.SolutionID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getStarredSolutionBySolutionID = `-- name: GetStarredSolutionBySolutionID :one
SELECT COUNT(*) > 0 
FROM starred_solution 
WHERE starred_solution.user_id = $1 
  AND solution_id = $2
`

type GetStarredSolutionBySolutionIDParams struct {
	UserID     string `json:"userId"`
	SolutionID int32  `json:"solutionId"`
}

func (q *Queries) GetStarredSolutionBySolutionID(ctx context.Context, arg GetStarredSolutionBySolutionIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, getStarredSolutionBySolutionID, arg.UserID, arg.SolutionID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getStarredSolutions = `-- name: GetStarredSolutions :many
SELECT 
    s.id, s.user_id, s.problem_id, s.title, s.body, s.created_at, s.votes, s.tags,
    EXISTS (
        SELECT 1
        FROM starred_solution ss
        WHERE ss.user_id = $1 
          AND ss.solution_id = s.id
    ) AS starred,
    (SELECT username FROM account WHERE id = $1) AS username
FROM solution s
`

type GetStarredSolutionsRow struct {
	ID        int64            `json:"id"`
	UserID    pgtype.Text      `json:"userId"`
	ProblemID pgtype.Int8      `json:"problemId"`
	Title     string           `json:"title"`
	Body      string           `json:"body"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Votes     pgtype.Int4      `json:"votes"`
	Tags      []string         `json:"tags"`
	Starred   bool             `json:"starred"`
	Username  string           `json:"username"`
}

func (q *Queries) GetStarredSolutions(ctx context.Context, userID string) ([]GetStarredSolutionsRow, error) {
	rows, err := q.db.Query(ctx, getStarredSolutions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStarredSolutionsRow
	for rows.Next() {
		var i GetStarredSolutionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProblemID,
			&i.Title,
			&i.Body,
			&i.CreatedAt,
			&i.Votes,
			&i.Tags,
			&i.Starred,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredSolutionsBySolutionID = `-- name: GetStarredSolutionsBySolutionID :many
SELECT id, user_id, solution_id, created_at FROM starred_solution WHERE user_id = $1 AND solution_id = $2
`

type GetStarredSolutionsBySolutionIDParams struct {
	UserID     string `json:"userId"`
	SolutionID int32  `json:"solutionId"`
}

func (q *Queries) GetStarredSolutionsBySolutionID(ctx context.Context, arg GetStarredSolutionsBySolutionIDParams) ([]StarredSolution, error) {
	rows, err := q.db.Query(ctx, getStarredSolutionsBySolutionID, arg.UserID, arg.SolutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StarredSolution
	for rows.Next() {
		var i StarredSolution
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SolutionID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStarredSubmissionBySubmissionID = `-- name: GetStarredSubmissionBySubmissionID :one
SELECT COUNT(*) > 0 FROM starred_submission WHERE user_id = $1 AND submission_id = $2
`

type GetStarredSubmissionBySubmissionIDParams struct {
	UserID       string      `json:"userId"`
	SubmissionID pgtype.UUID `json:"submissionId"`
}

func (q *Queries) GetStarredSubmissionBySubmissionID(ctx context.Context, arg GetStarredSubmissionBySubmissionIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, getStarredSubmissionBySubmissionID, arg.UserID, arg.SubmissionID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getStarredSubmissions = `-- name: GetStarredSubmissions :many
SELECT 
    s.id, s.stdout, s.time, s.memory, s.stderr, s.compile_output, s.message, s.status, s.language_id, s.language_name, s.created_at, s.account_id, s.submitted_code, s.submitted_stdin, s.failed_test_case, s.passed_test_cases, s.total_test_cases, s.problem_id,
    EXISTS (
        SELECT 1
        FROM starred_submission ss
        WHERE ss.user_id = $1 
          AND ss.submission_id = s.id
    ) AS starred,
    (SELECT account.id FROM account WHERE account.id = s.account_id) AS account_id,
    (SELECT submitted_code FROM submission WHERE id = s.id) AS submitted_code,
    (SELECT submitted_stdin FROM submission WHERE id = s.id) AS submitted_stdin,
    (SELECT created_at FROM submission WHERE id = s.id) AS created_at
FROM submission s
`

type GetStarredSubmissionsRow struct {
	ID               pgtype.UUID      `json:"id"`
	Stdout           pgtype.Text      `json:"stdout"`
	Time             pgtype.Text      `json:"time"`
	Memory           pgtype.Int4      `json:"memory"`
	Stderr           pgtype.Text      `json:"stderr"`
	CompileOutput    pgtype.Text      `json:"compileOutput"`
	Message          pgtype.Text      `json:"message"`
	Status           SubmissionStatus `json:"status"`
	LanguageID       int32            `json:"languageId"`
	LanguageName     string           `json:"languageName"`
	CreatedAt        pgtype.Timestamp `json:"createdAt"`
	AccountID        string           `json:"accountId"`
	SubmittedCode    string           `json:"submittedCode"`
	SubmittedStdin   pgtype.Text      `json:"submittedStdin"`
	FailedTestCase   []byte           `json:"failedTestCase"`
	PassedTestCases  pgtype.Int4      `json:"passedTestCases"`
	TotalTestCases   pgtype.Int4      `json:"totalTestCases"`
	ProblemID        int32            `json:"problemId"`
	Starred          bool             `json:"starred"`
	AccountID_2      string           `json:"accountId2"`
	SubmittedCode_2  string           `json:"submittedCode2"`
	SubmittedStdin_2 pgtype.Text      `json:"submittedStdin2"`
	CreatedAt_2      pgtype.Timestamp `json:"createdAt2"`
}

func (q *Queries) GetStarredSubmissions(ctx context.Context, userID string) ([]GetStarredSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, getStarredSubmissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStarredSubmissionsRow
	for rows.Next() {
		var i GetStarredSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Stdout,
			&i.Time,
			&i.Memory,
			&i.Stderr,
			&i.CompileOutput,
			&i.Message,
			&i.Status,
			&i.LanguageID,
			&i.LanguageName,
			&i.CreatedAt,
			&i.AccountID,
			&i.SubmittedCode,
			&i.SubmittedStdin,
			&i.FailedTestCase,
			&i.PassedTestCases,
			&i.TotalTestCases,
			&i.ProblemID,
			&i.Starred,
			&i.AccountID_2,
			&i.SubmittedCode_2,
			&i.SubmittedStdin_2,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putStarredProblem = `-- name: PutStarredProblem :one
WITH deleted(starred) AS (
    DELETE FROM starred_problem AS sp
    WHERE sp.user_id = $1 AND sp.problem_id = $2
    RETURNING false AS starred
),
inserted(starred) AS (
    INSERT INTO starred_problem (user_id, problem_id)
    SELECT v.user_id, v.problem_id
    FROM (VALUES ($1, $2)) AS v(user_id, problem_id)
    WHERE NOT EXISTS (SELECT 1 FROM deleted)
    RETURNING true AS starred
)
SELECT starred
FROM deleted
UNION ALL
SELECT starred
FROM inserted
LIMIT 1
`

type PutStarredProblemParams struct {
	UserID    string `json:"userId"`
	ProblemID int32  `json:"problemId"`
}

func (q *Queries) PutStarredProblem(ctx context.Context, arg PutStarredProblemParams) (bool, error) {
	row := q.db.QueryRow(ctx, putStarredProblem, arg.UserID, arg.ProblemID)
	var starred bool
	err := row.Scan(&starred)
	return starred, err
}

const putStarredSolution = `-- name: PutStarredSolution :one
WITH deleted(starred) AS (
    DELETE FROM starred_solution AS ss
    WHERE ss.user_id = $1 
      AND ss.solution_id = $2
    RETURNING false AS starred
),
inserted(starred) AS (
    INSERT INTO starred_solution (user_id, solution_id)
    SELECT v.user_id, v.solution_id
    FROM (VALUES ($1, $2)) AS v(user_id, solution_id)
    WHERE NOT EXISTS (SELECT 1 FROM deleted)
    RETURNING true AS starred
)
SELECT starred
FROM deleted
UNION ALL
SELECT starred
FROM inserted
LIMIT 1
`

type PutStarredSolutionParams struct {
	UserID     string `json:"userId"`
	SolutionID int32  `json:"solutionId"`
}

func (q *Queries) PutStarredSolution(ctx context.Context, arg PutStarredSolutionParams) (bool, error) {
	row := q.db.QueryRow(ctx, putStarredSolution, arg.UserID, arg.SolutionID)
	var starred bool
	err := row.Scan(&starred)
	return starred, err
}

const putStarredSubmission = `-- name: PutStarredSubmission :one
WITH deleted(starred) AS (
    DELETE FROM starred_submission AS ss
    WHERE ss.user_id = $1 AND ss.submission_id = $2
    RETURNING false AS starred
),
inserted(starred) AS (
    INSERT INTO starred_submission (user_id, submission_id)
    SELECT v.user_id, v.submission_id
    FROM (VALUES ($1, $2)) AS v(user_id, submission_id)
    WHERE NOT EXISTS (SELECT 1 FROM deleted)
    RETURNING true AS starred
)
SELECT starred
FROM deleted
UNION ALL
SELECT starred
FROM inserted
LIMIT 1
`

type PutStarredSubmissionParams struct {
	UserID       string      `json:"userId"`
	SubmissionID pgtype.UUID `json:"submissionId"`
}

func (q *Queries) PutStarredSubmission(ctx context.Context, arg PutStarredSubmissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, putStarredSubmission, arg.UserID, arg.SubmissionID)
	var starred bool
	err := row.Scan(&starred)
	return starred, err
}
