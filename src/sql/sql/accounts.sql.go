// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: accounts.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :exec

INSERT INTO account (id, username, email) VALUES ($1, $2, $3)
`

type CreateAccountParams struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

// POST --
func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.Exec(ctx, createAccount, arg.ID, arg.Username, arg.Email)
	return err
}

const createAccountAttributes = `-- name: CreateAccountAttributes :one
INSERT INTO account_attribute (
    id,
    bio,
    contact_email,
    location,
    real_name,
    github_url,
    linkedin_url,
    facebook_url,
    instagram_url,
    twitter_url,
    school,
    website_url
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
RETURNING 
    id,
    bio,
    contact_email,
    location,
    real_name,
    github_url,
    linkedin_url,
    facebook_url,
    instagram_url,
    twitter_url,
    school,
    website_url
`

type CreateAccountAttributesParams struct {
	ID           string      `json:"id"`
	Bio          pgtype.Text `json:"bio"`
	ContactEmail pgtype.Text `json:"contactEmail"`
	Location     pgtype.Text `json:"location"`
	RealName     pgtype.Text `json:"realName"`
	GithubUrl    pgtype.Text `json:"githubUrl"`
	LinkedinUrl  pgtype.Text `json:"linkedinUrl"`
	FacebookUrl  pgtype.Text `json:"facebookUrl"`
	InstagramUrl pgtype.Text `json:"instagramUrl"`
	TwitterUrl   pgtype.Text `json:"twitterUrl"`
	School       pgtype.Text `json:"school"`
	WebsiteUrl   pgtype.Text `json:"websiteUrl"`
}

func (q *Queries) CreateAccountAttributes(ctx context.Context, arg CreateAccountAttributesParams) (AccountAttribute, error) {
	row := q.db.QueryRow(ctx, createAccountAttributes,
		arg.ID,
		arg.Bio,
		arg.ContactEmail,
		arg.Location,
		arg.RealName,
		arg.GithubUrl,
		arg.LinkedinUrl,
		arg.FacebookUrl,
		arg.InstagramUrl,
		arg.TwitterUrl,
		arg.School,
		arg.WebsiteUrl,
	)
	var i AccountAttribute
	err := row.Scan(
		&i.ID,
		&i.Bio,
		&i.ContactEmail,
		&i.Location,
		&i.RealName,
		&i.GithubUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.TwitterUrl,
		&i.School,
		&i.WebsiteUrl,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec

WITH deleted_friendships AS (
    DELETE FROM friendship 
    WHERE user_id_1 = $1 OR user_id_2 = $1
), deleted_starred_problems AS (
    DELETE FROM starred_problem
    WHERE user_id = $1
), deleted_starred_submissions AS (
    DELETE FROM starred_submission
    WHERE user_id = $1
), deleted_starred_solutions_user AS (
    DELETE FROM starred_solution
    WHERE user_id = $1
), deleted_starred_solutions_owned AS (
    DELETE FROM starred_solution
    WHERE solution_id IN (SELECT id FROM solution WHERE user_id = $1)
), deleted_solutions AS (
    DELETE FROM solution
    WHERE user_id = $1
)
DELETE FROM account AS a WHERE a.id = $1
`

// DELETE --
func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one

SELECT 
    a.id, a.username, a.email, a.created_at, a.avatar_url, a.admin, a.plan, a.level,
    CASE 
        WHEN $2::boolean THEN
            json_build_object(
                'bio', COALESCE(aa.bio, ''),
                'contactEmail', COALESCE(aa.contact_email, ''),
                'location', COALESCE(aa.location, ''),
                'realName', COALESCE(aa.real_name, ''),
                'githubUrl', COALESCE(aa.github_url, ''),
                'linkedinUrl', COALESCE(aa.linkedin_url, ''),
                'facebookUrl', COALESCE(aa.facebook_url, ''),
                'instagramUrl', COALESCE(aa.instagram_url, ''),
                'twitterUrl', COALESCE(aa.twitter_url, ''),
                'school', COALESCE(aa.school, ''),
                'websiteUrl', COALESCE(aa.website_url, ''),
                'friends', COALESCE(f.count, 0),
                'blockedUsers', COALESCE(f2.count, 0),
                'friendRequests', COALESCE(f3.count, 0)
            )
        ELSE
            NULL
        END as attributes
    FROM account a
    LEFT JOIN account_attribute aa ON a.id = aa.id
    LEFT JOIN friendship f ON a.id = f.user_id_1 OR a.id = f.user_id_2 AND f.status = 'accepted'
    LEFT JOIN friendship f2 ON a.id = f2.user_id_1 OR a.id = f2.user_id_2 AND f2.status = 'blocked'
    LEFT JOIN friendship f3 ON a.id = f3.user_id_1 OR a.id = f3.user_id_2 AND f3.status = 'pending'
    WHERE
        a.id = $1 AND
        CASE WHEN array_length($3::text[], 1) > 0 THEN
            a.username = ANY($3::text[])
        ELSE
            TRUE
        END
        AND 
        CASE WHEN $2::boolean AND array_length($4::text[], 1) > 0 THEN
            aa.location = ANY($4::text[])
        ELSE
            TRUE
        END
    GROUP BY a.id, aa.id
    ORDER BY 
        (CASE WHEN $5 = 'level' AND $6 = 'ASC' THEN a.level END) ASC,
        (CASE WHEN $5 = 'level' AND $6 = 'DESC' THEN a.level END) DESC
    LIMIT 1
`

type GetAccountParams struct {
	ID                string      `json:"id"`
	IncludeAttributes bool        `json:"includeAttributes"`
	UsernamesFilter   []string    `json:"usernamesFilter"`
	LocationsFilter   []string    `json:"locationsFilter"`
	Sort              interface{} `json:"sort"`
	SortDirection     interface{} `json:"sortDirection"`
}

type GetAccountRow struct {
	ID         string           `json:"id"`
	Username   string           `json:"username"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	AvatarUrl  pgtype.Text      `json:"avatarUrl"`
	Admin      bool             `json:"admin"`
	Plan       AccountPlan      `json:"plan"`
	Level      int32            `json:"level"`
	Attributes interface{}      `json:"attributes"`
}

// GET --
func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccount,
		arg.ID,
		arg.IncludeAttributes,
		arg.UsernamesFilter,
		arg.LocationsFilter,
		arg.Sort,
		arg.SortDirection,
	)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.AvatarUrl,
		&i.Admin,
		&i.Plan,
		&i.Level,
		&i.Attributes,
	)
	return i, err
}

const getAccountAttributes = `-- name: GetAccountAttributes :one
SELECT id, bio, contact_email, location, real_name, github_url, linkedin_url, facebook_url, instagram_url, twitter_url, school, website_url FROM account_attribute WHERE id = $1
`

func (q *Queries) GetAccountAttributes(ctx context.Context, id string) (AccountAttribute, error) {
	row := q.db.QueryRow(ctx, getAccountAttributes, id)
	var i AccountAttribute
	err := row.Scan(
		&i.ID,
		&i.Bio,
		&i.ContactEmail,
		&i.Location,
		&i.RealName,
		&i.GithubUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.TwitterUrl,
		&i.School,
		&i.WebsiteUrl,
	)
	return i, err
}

const getAccountAttributesWithAccount = `-- name: GetAccountAttributesWithAccount :one
SELECT account_attribute.id, bio, contact_email, location, real_name, github_url, linkedin_url, facebook_url, instagram_url, twitter_url, school, website_url, account.id, username, email, created_at, avatar_url, admin, plan, level FROM account_attribute
JOIN account ON account_attribute.id = account.id
WHERE account.id = $1
`

type GetAccountAttributesWithAccountRow struct {
	ID           string           `json:"id"`
	Bio          pgtype.Text      `json:"bio"`
	ContactEmail pgtype.Text      `json:"contactEmail"`
	Location     pgtype.Text      `json:"location"`
	RealName     pgtype.Text      `json:"realName"`
	GithubUrl    pgtype.Text      `json:"githubUrl"`
	LinkedinUrl  pgtype.Text      `json:"linkedinUrl"`
	FacebookUrl  pgtype.Text      `json:"facebookUrl"`
	InstagramUrl pgtype.Text      `json:"instagramUrl"`
	TwitterUrl   pgtype.Text      `json:"twitterUrl"`
	School       pgtype.Text      `json:"school"`
	WebsiteUrl   pgtype.Text      `json:"websiteUrl"`
	ID_2         string           `json:"id2"`
	Username     string           `json:"username"`
	Email        string           `json:"email"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	AvatarUrl    pgtype.Text      `json:"avatarUrl"`
	Admin        bool             `json:"admin"`
	Plan         AccountPlan      `json:"plan"`
	Level        int32            `json:"level"`
}

func (q *Queries) GetAccountAttributesWithAccount(ctx context.Context, id string) (GetAccountAttributesWithAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccountAttributesWithAccount, id)
	var i GetAccountAttributesWithAccountRow
	err := row.Scan(
		&i.ID,
		&i.Bio,
		&i.ContactEmail,
		&i.Location,
		&i.RealName,
		&i.GithubUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.TwitterUrl,
		&i.School,
		&i.WebsiteUrl,
		&i.ID_2,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.AvatarUrl,
		&i.Admin,
		&i.Plan,
		&i.Level,
	)
	return i, err
}

const getAccountAvatarUrl = `-- name: GetAccountAvatarUrl :one
SELECT avatar_url from account WHERE id = $1
`

func (q *Queries) GetAccountAvatarUrl(ctx context.Context, id string) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getAccountAvatarUrl, id)
	var avatar_url pgtype.Text
	err := row.Scan(&avatar_url)
	return avatar_url, err
}

const getAccountByUsername = `-- name: GetAccountByUsername :one
SELECT 
    a.id, a.username, a.email, a.created_at, a.avatar_url, a.admin, a.plan, a.level,
    CASE
        WHEN f.user_id_1 = $1::text OR f.user_id_2 = $1::text THEN 
            CASE
                WHEN f.status = 'accepted' THEN 'friend'::text
                WHEN f.status = 'blocked' THEN 'blocked'::text
                WHEN f.status = 'pending' THEN 
                    CASE 
                        WHEN f.initiator_id = $1::text THEN 'request_sent'::text
                        ELSE 'request_received'::text
                    END
                ELSE 'none'::text
            END
        ELSE 'none'::text
    END as friend_status,
    CASE 
        WHEN $2::boolean THEN
            json_build_object(
                'bio', COALESCE(aa.bio, ''),
                'contactEmail', COALESCE(aa.contact_email, ''),
                'location', COALESCE(aa.location, ''),
                'realName', COALESCE(aa.real_name, ''),
                'githubUrl', COALESCE(aa.github_url, ''),
                'linkedinUrl', COALESCE(aa.linkedin_url, ''),
                'facebookUrl', COALESCE(aa.facebook_url, ''),
                'instagramUrl', COALESCE(aa.instagram_url, ''),
                'twitterUrl', COALESCE(aa.twitter_url, ''),
                'school', COALESCE(aa.school, ''),
                'websiteUrl', COALESCE(aa.website_url, ''),
                'friendCount', COUNT(DISTINCT CASE WHEN f2.status = 'accepted' THEN f2.user_id_1 END),
                'blockedCount', COUNT(DISTINCT CASE WHEN f3.status = 'blocked' THEN f3.user_id_1 END),
                'friendRequestCount', COUNT(DISTINCT CASE WHEN f4.status = 'pending' THEN f4.user_id_1 END)
            )
        ELSE
            NULL
        END as attributes
    FROM account a
    LEFT JOIN account_attribute aa ON a.id = aa.id
    LEFT JOIN friendship f ON (a.id = f.user_id_1 AND f.user_id_2 = $1::text) 
        OR (a.id = f.user_id_2 AND f.user_id_1 = $1::text)
    LEFT JOIN friendship f2 ON (a.id = f2.user_id_1 OR a.id = f2.user_id_2) AND f2.status = 'accepted'
    LEFT JOIN friendship f3 ON (a.id = f3.user_id_1 OR a.id = f3.user_id_2) AND f3.status = 'blocked'
    LEFT JOIN friendship f4 ON (a.id = f4.user_id_1 OR a.id = f4.user_id_2) AND f4.status = 'pending'
    WHERE a.username = $3::text
    GROUP BY a.id, aa.id, f.status, f.user_id_1, f.user_id_2
`

type GetAccountByUsernameParams struct {
	UserID            string `json:"userId"`
	IncludeAttributes bool   `json:"includeAttributes"`
	Username          string `json:"username"`
}

type GetAccountByUsernameRow struct {
	ID           string           `json:"id"`
	Username     string           `json:"username"`
	Email        string           `json:"email"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	AvatarUrl    pgtype.Text      `json:"avatarUrl"`
	Admin        bool             `json:"admin"`
	Plan         AccountPlan      `json:"plan"`
	Level        int32            `json:"level"`
	FriendStatus string           `json:"friendStatus"`
	Attributes   interface{}      `json:"attributes"`
}

func (q *Queries) GetAccountByUsername(ctx context.Context, arg GetAccountByUsernameParams) (GetAccountByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getAccountByUsername, arg.UserID, arg.IncludeAttributes, arg.Username)
	var i GetAccountByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.AvatarUrl,
		&i.Admin,
		&i.Plan,
		&i.Level,
		&i.FriendStatus,
		&i.Attributes,
	)
	return i, err
}

const getAccountExists = `-- name: GetAccountExists :one
SELECT EXISTS (SELECT 1 FROM account WHERE id = $1)
`

func (q *Queries) GetAccountExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, getAccountExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountIDByUsername = `-- name: GetAccountIDByUsername :one
SELECT id from account WHERE username = $1
`

func (q *Queries) GetAccountIDByUsername(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, getAccountIDByUsername, username)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getAccountLevel = `-- name: GetAccountLevel :one
SELECT level from account WHERE id = $1
`

func (q *Queries) GetAccountLevel(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRow(ctx, getAccountLevel, id)
	var level int32
	err := row.Scan(&level)
	return level, err
}

const getAccountPlan = `-- name: GetAccountPlan :one
SELECT plan FROM account WHERE id = $1
`

func (q *Queries) GetAccountPlan(ctx context.Context, id string) (AccountPlan, error) {
	row := q.db.QueryRow(ctx, getAccountPlan, id)
	var plan AccountPlan
	err := row.Scan(&plan)
	return plan, err
}

const getAccountUsername = `-- name: GetAccountUsername :one
SELECT username from account WHERE id = $1
`

func (q *Queries) GetAccountUsername(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getAccountUsername, id)
	var username string
	err := row.Scan(&username)
	return username, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT 
    a.id, a.username, a.email, a.created_at, a.avatar_url, a.admin, a.plan, a.level,
    CASE 
        WHEN $1::boolean THEN
            json_build_object(
                'bio', COALESCE(aa.bio, ''),
                'contactEmail', COALESCE(aa.contact_email, ''),
                'location', COALESCE(aa.location, ''),
                'realName', COALESCE(aa.real_name, ''),
                'githubUrl', COALESCE(aa.github_url, ''),
                'linkedinUrl', COALESCE(aa.linkedin_url, ''),
                'facebookUrl', COALESCE(aa.facebook_url, ''),
                'instagramUrl', COALESCE(aa.instagram_url, ''),
                'twitterUrl', COALESCE(aa.twitter_url, ''),
                'school', COALESCE(aa.school, ''),
                'websiteUrl', COALESCE(aa.website_url, ''),
                'friendCount', COUNT(DISTINCT CASE WHEN f.status = 'accepted' THEN f.user_id_1 END),
                'blockedCount', COUNT(DISTINCT CASE WHEN f2.status = 'blocked' THEN f2.user_id_1 END),
                'friendRequestCount', COUNT(DISTINCT CASE WHEN f3.status = 'pending' THEN f3.user_id_1 END)
            )
        ELSE
            NULL
        END as attributes
    FROM account a
    LEFT JOIN account_attribute aa ON a.id = aa.id
    LEFT JOIN friendship f ON (a.id = f.user_id_1 OR a.id = f.user_id_2)
    LEFT JOIN friendship f2 ON (a.id = f2.user_id_1 OR a.id = f2.user_id_2)
    LEFT JOIN friendship f3 ON (a.id = f3.user_id_1 OR a.id = f3.user_id_2)
    WHERE
        CASE WHEN array_length($2::text[], 1) > 0 THEN
            a.username = ANY($2::text[])
        ELSE
            TRUE
        END
        AND 
        CASE WHEN $1::boolean AND array_length($3::text[], 1) > 0 THEN
            aa.location = ANY($3::text[])
        ELSE
            TRUE
        END
    GROUP BY a.id, aa.id, aa.bio, aa.contact_email, aa.location, aa.real_name, 
             aa.github_url, aa.linkedin_url, aa.facebook_url, aa.instagram_url, 
             aa.twitter_url, aa.school, aa.website_url
    ORDER BY 
        (CASE WHEN $4 = 'level' AND $5 = 'ASC' THEN a.level END) ASC,
        (CASE WHEN $4 = 'level' AND $5 = 'DESC' THEN a.level END) DESC
`

type GetAccountsParams struct {
	IncludeAttributes bool        `json:"includeAttributes"`
	UsernamesFilter   []string    `json:"usernamesFilter"`
	LocationsFilter   []string    `json:"locationsFilter"`
	Sort              interface{} `json:"sort"`
	SortDirection     interface{} `json:"sortDirection"`
}

type GetAccountsRow struct {
	ID         string           `json:"id"`
	Username   string           `json:"username"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	AvatarUrl  pgtype.Text      `json:"avatarUrl"`
	Admin      bool             `json:"admin"`
	Plan       AccountPlan      `json:"plan"`
	Level      int32            `json:"level"`
	Attributes interface{}      `json:"attributes"`
}

func (q *Queries) GetAccounts(ctx context.Context, arg GetAccountsParams) ([]GetAccountsRow, error) {
	rows, err := q.db.Query(ctx, getAccounts,
		arg.IncludeAttributes,
		arg.UsernamesFilter,
		arg.LocationsFilter,
		arg.Sort,
		arg.SortDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.CreatedAt,
			&i.AvatarUrl,
			&i.Admin,
			&i.Plan,
			&i.Level,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountAttributes = `-- name: UpdateAccountAttributes :one
UPDATE account_attribute
SET bio = $1, contact_email = $2, location = $3, real_name = $4, github_url = $5, linkedin_url = $6, facebook_url = $7, instagram_url = $8, twitter_url = $9, school = $10, website_url = $11
WHERE id = $12 RETURNING id, bio, contact_email, location, real_name, github_url, linkedin_url, facebook_url, instagram_url, twitter_url, school, website_url
`

type UpdateAccountAttributesParams struct {
	Bio          pgtype.Text `json:"bio"`
	ContactEmail pgtype.Text `json:"contactEmail"`
	Location     pgtype.Text `json:"location"`
	RealName     pgtype.Text `json:"realName"`
	GithubUrl    pgtype.Text `json:"githubUrl"`
	LinkedinUrl  pgtype.Text `json:"linkedinUrl"`
	FacebookUrl  pgtype.Text `json:"facebookUrl"`
	InstagramUrl pgtype.Text `json:"instagramUrl"`
	TwitterUrl   pgtype.Text `json:"twitterUrl"`
	School       pgtype.Text `json:"school"`
	WebsiteUrl   pgtype.Text `json:"websiteUrl"`
	ID           string      `json:"id"`
}

func (q *Queries) UpdateAccountAttributes(ctx context.Context, arg UpdateAccountAttributesParams) (AccountAttribute, error) {
	row := q.db.QueryRow(ctx, updateAccountAttributes,
		arg.Bio,
		arg.ContactEmail,
		arg.Location,
		arg.RealName,
		arg.GithubUrl,
		arg.LinkedinUrl,
		arg.FacebookUrl,
		arg.InstagramUrl,
		arg.TwitterUrl,
		arg.School,
		arg.WebsiteUrl,
		arg.ID,
	)
	var i AccountAttribute
	err := row.Scan(
		&i.ID,
		&i.Bio,
		&i.ContactEmail,
		&i.Location,
		&i.RealName,
		&i.GithubUrl,
		&i.LinkedinUrl,
		&i.FacebookUrl,
		&i.InstagramUrl,
		&i.TwitterUrl,
		&i.School,
		&i.WebsiteUrl,
	)
	return i, err
}

const updateAvatar = `-- name: UpdateAvatar :exec

UPDATE account
SET avatar_url = $1
WHERE id = $2
`

type UpdateAvatarParams struct {
	AvatarUrl pgtype.Text `json:"avatarUrl"`
	ID        string      `json:"id"`
}

// PUT --
func (q *Queries) UpdateAvatar(ctx context.Context, arg UpdateAvatarParams) error {
	_, err := q.db.Exec(ctx, updateAvatar, arg.AvatarUrl, arg.ID)
	return err
}
