// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: problems.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProblem = `-- name: CreateProblem :one
INSERT INTO problem (title, description, function_name, points, tags, difficulty) VALUES ($1, $2::text, $3, $4, $5, $6) RETURNING id
`

type CreateProblemParams struct {
	Title        string            `json:"title"`
	Description  string            `json:"description"`
	FunctionName string            `json:"functionName"`
	Points       int32             `json:"points"`
	Tags         []string          `json:"tags"`
	Difficulty   ProblemDifficulty `json:"difficulty"`
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProblem,
		arg.Title,
		arg.Description,
		arg.FunctionName,
		arg.Points,
		arg.Tags,
		arg.Difficulty,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProblemCode = `-- name: CreateProblemCode :exec
INSERT INTO problem_code (problem_id, language, code) VALUES ($1::int, $2::problem_language, $3::text)
`

type CreateProblemCodeParams struct {
	ProblemID int32           `json:"problemId"`
	Language  ProblemLanguage `json:"language"`
	Code      string          `json:"code"`
}

func (q *Queries) CreateProblemCode(ctx context.Context, arg CreateProblemCodeParams) error {
	_, err := q.db.Exec(ctx, createProblemCode, arg.ProblemID, arg.Language, arg.Code)
	return err
}

const createProblemHint = `-- name: CreateProblemHint :exec
INSERT INTO problem_hint (problem_id, description, answer) VALUES ($1::int, $2::text, $3::text)
`

type CreateProblemHintParams struct {
	ProblemID   int32  `json:"problemId"`
	Description string `json:"description"`
	Answer      string `json:"answer"`
}

func (q *Queries) CreateProblemHint(ctx context.Context, arg CreateProblemHintParams) error {
	_, err := q.db.Exec(ctx, createProblemHint, arg.ProblemID, arg.Description, arg.Answer)
	return err
}

const createProblemSolution = `-- name: CreateProblemSolution :one
INSERT INTO problem_solution (problem_id, language, code) VALUES ($1::int, $2::problem_language, $3::text) RETURNING id, problem_id, language, code, created_at
`

type CreateProblemSolutionParams struct {
	ProblemID int32           `json:"problemId"`
	Language  ProblemLanguage `json:"language"`
	Code      string          `json:"code"`
}

func (q *Queries) CreateProblemSolution(ctx context.Context, arg CreateProblemSolutionParams) (ProblemSolution, error) {
	row := q.db.QueryRow(ctx, createProblemSolution, arg.ProblemID, arg.Language, arg.Code)
	var i ProblemSolution
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.Language,
		&i.Code,
		&i.CreatedAt,
	)
	return i, err
}

const createProblemTestCase = `-- name: CreateProblemTestCase :one
INSERT INTO problem_test_case (problem_id, description, visibility) VALUES ($1::int, $2::text, $3::visibility) RETURNING id, problem_id, description, created_at, visibility
`

type CreateProblemTestCaseParams struct {
	ProblemID   int32      `json:"problemId"`
	Description string     `json:"description"`
	Visibility  Visibility `json:"visibility"`
}

func (q *Queries) CreateProblemTestCase(ctx context.Context, arg CreateProblemTestCaseParams) (ProblemTestCase, error) {
	row := q.db.QueryRow(ctx, createProblemTestCase, arg.ProblemID, arg.Description, arg.Visibility)
	var i ProblemTestCase
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.Description,
		&i.CreatedAt,
		&i.Visibility,
	)
	return i, err
}

const createProblemTestCaseInput = `-- name: CreateProblemTestCaseInput :one
INSERT INTO problem_test_case_input (problem_test_case_id, name, value, type) VALUES ($1::int, $2::text, $3::text, $4::problem_test_case_type) RETURNING id, problem_test_case_id, name, type, value, created_at
`

type CreateProblemTestCaseInputParams struct {
	ProblemTestCaseID int32               `json:"problemTestCaseId"`
	Name              string              `json:"name"`
	Value             string              `json:"value"`
	Type              ProblemTestCaseType `json:"type"`
}

func (q *Queries) CreateProblemTestCaseInput(ctx context.Context, arg CreateProblemTestCaseInputParams) (ProblemTestCaseInput, error) {
	row := q.db.QueryRow(ctx, createProblemTestCaseInput,
		arg.ProblemTestCaseID,
		arg.Name,
		arg.Value,
		arg.Type,
	)
	var i ProblemTestCaseInput
	err := row.Scan(
		&i.ID,
		&i.ProblemTestCaseID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const createProblemTestCaseOutput = `-- name: CreateProblemTestCaseOutput :one
INSERT INTO problem_test_case_output (problem_test_case_id, value) VALUES ($1::int, $2::text) RETURNING id, problem_test_case_id, value, created_at
`

type CreateProblemTestCaseOutputParams struct {
	ProblemTestCaseID int32  `json:"problemTestCaseId"`
	Value             string `json:"value"`
}

func (q *Queries) CreateProblemTestCaseOutput(ctx context.Context, arg CreateProblemTestCaseOutputParams) (ProblemTestCaseOutput, error) {
	row := q.db.QueryRow(ctx, createProblemTestCaseOutput, arg.ProblemTestCaseID, arg.Value)
	var i ProblemTestCaseOutput
	err := row.Scan(
		&i.ID,
		&i.ProblemTestCaseID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getProblem = `-- name: GetProblem :one
SELECT
    p.id, p.title, p.description, p.function_name, p.points, p.created_at, p.difficulty, p.tags,
    (
        SELECT COALESCE(
            json_agg(
                json_build_object('language', pc.language, 'code', pc.code)
            ),
            '[]'
        )
        FROM problem_code pc 
        WHERE pc.problem_id = p.id
    ) AS code,
    
    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'description', ph.description,
                    'answer', ph.answer
                )
            ),
            '[]'
        )
        FROM problem_hint ph 
        WHERE ph.problem_id = p.id
    ) AS hints,
    
    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'description', pt.description,
                    'input',
                        (
                            SELECT json_agg(
                                json_build_object(
                                    'name', pti.name,
                                    'type', pti.type,
                                    'value', pti.value
                                )
                            )
                            FROM problem_test_case_input pti
                            WHERE pti.problem_test_case_id = pt.id
                        ),
                    'output',
                        (
                            SELECT pto.value
                            FROM problem_test_case_output pto
                            WHERE pto.problem_test_case_id = pt.id
                        )
                )
            ),
            '[]'
        )
        FROM problem_test_case pt 
        WHERE pt.problem_id = p.id AND pt.visibility = 'public'
    ) AS test_cases,
    
    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'language', ps.language,
                    'code', ps.code
                )
            ),
            '[]'
        )
        FROM problem_solution ps 
        WHERE ps.problem_id = p.id
    ) AS solutions,
    CASE WHEN EXISTS (SELECT 1 FROM starred_problem sp WHERE sp.problem_id = p.id AND sp.user_id = $1) THEN true ELSE false END AS starred,
    CASE WHEN EXISTS (SELECT 1 FROM submission s WHERE s.problem_id = p.id AND s.status = 'Accepted' AND s.account_id = $1) THEN true ELSE false END AS solved,
    COUNT(s.id)::int as total_attempts,
    COUNT(s.id) FILTER (WHERE s.status = 'Accepted')::int as total_correct
FROM problem p
LEFT JOIN submission s ON p.id = s.problem_id
WHERE p.id = $2::int
GROUP BY p.id
`

type GetProblemParams struct {
	UserID    string `json:"userId"`
	ProblemID int32  `json:"problemId"`
}

type GetProblemRow struct {
	ID            int32             `json:"id"`
	Title         string            `json:"title"`
	Description   pgtype.Text       `json:"description"`
	FunctionName  string            `json:"functionName"`
	Points        int32             `json:"points"`
	CreatedAt     pgtype.Timestamp  `json:"createdAt"`
	Difficulty    ProblemDifficulty `json:"difficulty"`
	Tags          []string          `json:"tags"`
	Code          interface{}       `json:"code"`
	Hints         interface{}       `json:"hints"`
	TestCases     interface{}       `json:"testCases"`
	Solutions     interface{}       `json:"solutions"`
	Starred       bool              `json:"starred"`
	Solved        bool              `json:"solved"`
	TotalAttempts int32             `json:"totalAttempts"`
	TotalCorrect  int32             `json:"totalCorrect"`
}

func (q *Queries) GetProblem(ctx context.Context, arg GetProblemParams) (GetProblemRow, error) {
	row := q.db.QueryRow(ctx, getProblem, arg.UserID, arg.ProblemID)
	var i GetProblemRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FunctionName,
		&i.Points,
		&i.CreatedAt,
		&i.Difficulty,
		&i.Tags,
		&i.Code,
		&i.Hints,
		&i.TestCases,
		&i.Solutions,
		&i.Starred,
		&i.Solved,
		&i.TotalAttempts,
		&i.TotalCorrect,
	)
	return i, err
}

const getProblemByDifficulty = `-- name: GetProblemByDifficulty :many
SELECT id, title, description, function_name, points, created_at, difficulty, tags FROM problem WHERE difficulty = $1::problem_difficulty ORDER BY RANDOM() LIMIT $3::int OFFSET (($2::int) - 1) * $3::int
`

type GetProblemByDifficultyParams struct {
	Difficulty ProblemDifficulty `json:"difficulty"`
	Page       int32             `json:"page"`
	PerPage    int32             `json:"perPage"`
}

func (q *Queries) GetProblemByDifficulty(ctx context.Context, arg GetProblemByDifficultyParams) ([]Problem, error) {
	rows, err := q.db.Query(ctx, getProblemByDifficulty, arg.Difficulty, arg.Page, arg.PerPage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FunctionName,
			&i.Points,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemByTitle = `-- name: GetProblemByTitle :one
SELECT id, title, description, function_name, points, created_at, difficulty, tags FROM problem WHERE title = $1::text
`

func (q *Queries) GetProblemByTitle(ctx context.Context, title string) (Problem, error) {
	row := q.db.QueryRow(ctx, getProblemByTitle, title)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FunctionName,
		&i.Points,
		&i.CreatedAt,
		&i.Difficulty,
		&i.Tags,
	)
	return i, err
}

const getProblemCode = `-- name: GetProblemCode :one
SELECT id, problem_id, language, code, created_at FROM problem_code WHERE problem_id = $1::int
`

func (q *Queries) GetProblemCode(ctx context.Context, problemID int32) (ProblemCode, error) {
	row := q.db.QueryRow(ctx, getProblemCode, problemID)
	var i ProblemCode
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.Language,
		&i.Code,
		&i.CreatedAt,
	)
	return i, err
}

const getProblemCodeByLanguage = `-- name: GetProblemCodeByLanguage :one
SELECT id, problem_id, language, code, created_at FROM problem_code WHERE problem_id = $1::int AND language = $2::problem_language
`

type GetProblemCodeByLanguageParams struct {
	ProblemID int32           `json:"problemId"`
	Language  ProblemLanguage `json:"language"`
}

func (q *Queries) GetProblemCodeByLanguage(ctx context.Context, arg GetProblemCodeByLanguageParams) (ProblemCode, error) {
	row := q.db.QueryRow(ctx, getProblemCodeByLanguage, arg.ProblemID, arg.Language)
	var i ProblemCode
	err := row.Scan(
		&i.ID,
		&i.ProblemID,
		&i.Language,
		&i.Code,
		&i.CreatedAt,
	)
	return i, err
}

const getProblemCodes = `-- name: GetProblemCodes :many
SELECT id, problem_id, language, code, created_at FROM problem_code WHERE problem_id = $1::int
`

func (q *Queries) GetProblemCodes(ctx context.Context, problemID int32) ([]ProblemCode, error) {
	rows, err := q.db.Query(ctx, getProblemCodes, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProblemCode
	for rows.Next() {
		var i ProblemCode
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.Language,
			&i.Code,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemHints = `-- name: GetProblemHints :many
SELECT id, problem_id, description, answer, created_at FROM problem_hint WHERE problem_id = $1::int
`

func (q *Queries) GetProblemHints(ctx context.Context, problemID int32) ([]ProblemHint, error) {
	rows, err := q.db.Query(ctx, getProblemHints, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProblemHint
	for rows.Next() {
		var i ProblemHint
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.Description,
			&i.Answer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemTestCases = `-- name: GetProblemTestCases :many
SELECT ptc.id, ptc.problem_id, ptc.description, ptc.created_at, ptc.visibility,
    (
        SELECT COALESCE(json_agg(
            json_build_object(
                'type', pti.type,
                'value', pti.value,
                'name', pti.name
            )
        ), '[]')
        FROM problem_test_case_input pti 
        WHERE pti.problem_test_case_id = ptc.id
    ) AS input,
    (
        SELECT COALESCE(value,'') FROM problem_test_case_output pto WHERE pto.problem_test_case_id = ptc.id
    ) AS output
FROM problem_test_case ptc
WHERE ptc.problem_id = $1::int 
    AND ($2::text = '' OR ptc.visibility = $2::visibility)
`

type GetProblemTestCasesParams struct {
	ProblemID  int32  `json:"problemId"`
	Visibility string `json:"visibility"`
}

type GetProblemTestCasesRow struct {
	ID          int32            `json:"id"`
	ProblemID   pgtype.Int4      `json:"problemId"`
	Description string           `json:"description"`
	CreatedAt   pgtype.Timestamp `json:"createdAt"`
	Visibility  Visibility       `json:"visibility"`
	Input       interface{}      `json:"input"`
	Output      string           `json:"output"`
}

func (q *Queries) GetProblemTestCases(ctx context.Context, arg GetProblemTestCasesParams) ([]GetProblemTestCasesRow, error) {
	rows, err := q.db.Query(ctx, getProblemTestCases, arg.ProblemID, arg.Visibility)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemTestCasesRow
	for rows.Next() {
		var i GetProblemTestCasesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProblemID,
			&i.Description,
			&i.CreatedAt,
			&i.Visibility,
			&i.Input,
			&i.Output,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblems = `-- name: GetProblems :many
WITH problem_data AS (
    SELECT 
        p.id,
        p.title,
        p.description,
        p.tags,
        p.difficulty,
        p.points,
        p.function_name,
        json_agg(
            json_build_object(
                'language', pc.language,
                'code', pc.code
            )
        ) FILTER (WHERE pc.id IS NOT NULL) as code,
        json_agg(
            json_build_object(
                'description', ph.description,
                'answer', ph.answer
            )
        ) FILTER (WHERE ph.id IS NOT NULL) as hint,
            (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'description', pt.description,
                    'input',
                        (
                            SELECT json_agg(
                                json_build_object(
                                    'name', pti.name,
                                    'type', pti.type,
                                    'value', pti.value
                                )
                            )
                            FROM problem_test_case_input pti
                            WHERE pti.problem_test_case_id = pt.id
                        ),
                    'output',
                        (
                            SELECT pto.value
                            FROM problem_test_case_output pto
                            WHERE pto.problem_test_case_id = pt.id
                        )
                )
            ),
            '[]'
        )
        FROM problem_test_case pt 
        WHERE pt.problem_id = p.id AND pt.visibility = 'public'
    ) AS test_cases_json,
        COUNT(s.id)::int as totalAttempts,
        COUNT(s.id) FILTER (WHERE s.status = 'completed' AND s.correct = true)::int as totalCorrect,
        CASE WHEN EXISTS (SELECT 1 FROM submission s WHERE s.problem_id = p.id AND s.status = 'Accepted' AND s.account_id = $1) THEN true ELSE false END AS solved
    FROM problem p
    LEFT JOIN problem_code pc ON p.id = pc.problem_id
    LEFT JOIN problem_hint ph ON p.id = ph.problem_id
    LEFT JOIN problem_test_case pt ON p.id = pt.problem_id
    LEFT JOIN submission s ON p.id = s.problem_id
    GROUP BY p.id, p.title, p.description, p.tags, p.difficulty, p.points
)
SELECT 
    id,
    title,
    description,
    tags,
    difficulty,
    points,
    COALESCE(code, '[]'::json) as code,
    COALESCE(hint, '[]'::json) as hint,
    COALESCE(test_cases_json, '[]'::json) as test_cases_json
FROM problem_data
ORDER BY points DESC
`

type GetProblemsRow struct {
	ID            int32             `json:"id"`
	Title         string            `json:"title"`
	Description   pgtype.Text       `json:"description"`
	Tags          []string          `json:"tags"`
	Difficulty    ProblemDifficulty `json:"difficulty"`
	Points        int32             `json:"points"`
	Code          []byte            `json:"code"`
	Hint          []byte            `json:"hint"`
	TestCasesJson interface{}       `json:"testCasesJson"`
}

func (q *Queries) GetProblems(ctx context.Context, userID string) ([]GetProblemsRow, error) {
	rows, err := q.db.Query(ctx, getProblems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsRow
	for rows.Next() {
		var i GetProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Tags,
			&i.Difficulty,
			&i.Points,
			&i.Code,
			&i.Hint,
			&i.TestCasesJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemsById = `-- name: GetProblemsById :many
SELECT id, title, description, function_name, points, created_at, difficulty, tags FROM problem WHERE id = ANY($1::int[])
`

func (q *Queries) GetProblemsById(ctx context.Context, ids []int32) ([]Problem, error) {
	rows, err := q.db.Query(ctx, getProblemsById, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Problem
	for rows.Next() {
		var i Problem
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FunctionName,
			&i.Points,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblemsFilteredPaginated = `-- name: GetProblemsFilteredPaginated :many
WITH filtered_problems AS (
    SELECT p.id
    FROM problem p
    LEFT JOIN submission s ON p.id = s.problem_id
    LEFT JOIN starred_problem sp ON p.id = sp.problem_id
    LEFT JOIN (
        SELECT status, problem_id
        FROM submission
        WHERE account_id = $1
    ) AS user_submissions ON p.id = user_submissions.problem_id
    WHERE
        ($2::text = '' OR p.title ILIKE '%' || $2::text || '%')
        AND ($3::text = '' OR p.difficulty = $3::problem_difficulty)
    GROUP BY p.id, sp.problem_id

    -- No ORDER BY / LIMIT / OFFSET here: this is the "full" matching set
)
SELECT
    p.id, p.title, p.description, p.function_name, p.points, p.created_at, p.difficulty, p.tags,
    (
        SELECT COALESCE(
            json_agg(
                json_build_object('language', pc.language, 'code', pc.code)
            ),
            '[]'
        )
        FROM problem_code pc 
        WHERE pc.problem_id = p.id
    ) AS code,
    
    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'description', ph.description,
                    'answer', ph.answer
                )
            ),
            '[]'
        )
        FROM problem_hint ph 
        WHERE ph.problem_id = p.id
    ) AS hints,

    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'description', pt.description,
                    'input',
                        (
                            SELECT json_agg(
                                json_build_object(
                                    'name', pti.name,
                                    'type', pti.type,
                                    'value', pti.value
                                )
                            )
                            FROM problem_test_case_input pti
                            WHERE pti.problem_test_case_id = pt.id
                        ),
                    'output',
                        (
                            SELECT pto.value
                            FROM problem_test_case_output pto
                            WHERE pto.problem_test_case_id = pt.id
                        )
                )
            ),
            '[]'
        )
        FROM problem_test_case pt 
        WHERE pt.problem_id = p.id AND pt.visibility = 'public'
    ) AS test_cases, 
    
    (
        SELECT COALESCE(
            json_agg(
                json_build_object(
                    'language', ps.language,
                    'code', ps.code
                )
            ),
            '[]'
        )
        FROM problem_solution ps 
        WHERE ps.problem_id = p.id
    ) AS solutions,
    COUNT(s.id)::int as total_attempts,
    COUNT(s.id) FILTER (WHERE s.status = 'Accepted')::int as total_correct,
    CASE
        WHEN sp.problem_id IS NOT NULL THEN TRUE
        ELSE FALSE
    END AS starred,
    CASE WHEN EXISTS (SELECT 1 FROM submission s WHERE s.problem_id = p.id AND s.status = 'Accepted' AND s.account_id = $1) THEN true ELSE false END AS solved,
    (SELECT COUNT(*) FROM filtered_problems)::int AS total_count
FROM problem p
LEFT JOIN submission s ON p.id = s.problem_id
LEFT JOIN starred_problem sp ON p.id = sp.problem_id
LEFT JOIN (
    SELECT status, problem_id
    FROM submission
    WHERE account_id = $1
) AS user_submissions ON p.id = user_submissions.problem_id
WHERE
    ($2::text = '' OR p.title ILIKE '%' || $2::text || '%')
    AND ($3::text = '' OR p.difficulty = $3::problem_difficulty)
GROUP BY p.id, sp.problem_id
ORDER BY
    CASE WHEN $4::problem_sort = 'alpha' AND $5::sort_direction = 'asc' THEN p.title END ASC,
    CASE WHEN $4::problem_sort = 'alpha' AND $5::sort_direction = 'desc' THEN p.title END DESC,
    CASE WHEN $4::problem_sort = 'index' AND $5::sort_direction = 'asc' THEN p.id END ASC,
    CASE WHEN $4::problem_sort = 'index' AND $5::sort_direction = 'desc' THEN p.id END DESC,
    p.id DESC
LIMIT $7::int
OFFSET (($6::int) - 1) * $7::int
`

type GetProblemsFilteredPaginatedParams struct {
	UserID        string        `json:"userId"`
	Title         string        `json:"title"`
	Difficulty    string        `json:"difficulty"`
	Sort          ProblemSort   `json:"sort"`
	SortDirection SortDirection `json:"sortDirection"`
	Page          int32         `json:"page"`
	PerPage       int32         `json:"perPage"`
}

type GetProblemsFilteredPaginatedRow struct {
	ID            int32             `json:"id"`
	Title         string            `json:"title"`
	Description   pgtype.Text       `json:"description"`
	FunctionName  string            `json:"functionName"`
	Points        int32             `json:"points"`
	CreatedAt     pgtype.Timestamp  `json:"createdAt"`
	Difficulty    ProblemDifficulty `json:"difficulty"`
	Tags          []string          `json:"tags"`
	Code          interface{}       `json:"code"`
	Hints         interface{}       `json:"hints"`
	TestCases     interface{}       `json:"testCases"`
	Solutions     interface{}       `json:"solutions"`
	TotalAttempts int32             `json:"totalAttempts"`
	TotalCorrect  int32             `json:"totalCorrect"`
	Starred       bool              `json:"starred"`
	Solved        bool              `json:"solved"`
	TotalCount    int32             `json:"totalCount"`
}

func (q *Queries) GetProblemsFilteredPaginated(ctx context.Context, arg GetProblemsFilteredPaginatedParams) ([]GetProblemsFilteredPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getProblemsFilteredPaginated,
		arg.UserID,
		arg.Title,
		arg.Difficulty,
		arg.Sort,
		arg.SortDirection,
		arg.Page,
		arg.PerPage,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsFilteredPaginatedRow
	for rows.Next() {
		var i GetProblemsFilteredPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FunctionName,
			&i.Points,
			&i.CreatedAt,
			&i.Difficulty,
			&i.Tags,
			&i.Code,
			&i.Hints,
			&i.TestCases,
			&i.Solutions,
			&i.TotalAttempts,
			&i.TotalCorrect,
			&i.Starred,
			&i.Solved,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
