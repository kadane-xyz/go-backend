// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: submissions.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submission (id, stdout, time, memory, stderr, compile_output, message, status, language_id, language_name, account_id, problem_id, submitted_code, submitted_stdin, failed_test_case, passed_test_cases, total_test_cases) VALUES ($1::uuid, $2::text, $3::text, $4::int, $5::text, $6::text, $7::text, $8, $9, $10, $11, $12, $13, $14, $15, $16::int, $17::int) RETURNING id, stdout, time, memory, stderr, compile_output, message, status, language_id, language_name, created_at, account_id, submitted_code, submitted_stdin, failed_test_case, passed_test_cases, total_test_cases, problem_id
`

type CreateSubmissionParams struct {
	ID              pgtype.UUID      `json:"id"`
	Stdout          string           `json:"stdout"`
	Time            string           `json:"time"`
	Memory          int32            `json:"memory"`
	Stderr          string           `json:"stderr"`
	CompileOutput   string           `json:"compileOutput"`
	Message         string           `json:"message"`
	Status          SubmissionStatus `json:"status"`
	LanguageID      int32            `json:"languageId"`
	LanguageName    string           `json:"languageName"`
	AccountID       string           `json:"accountId"`
	ProblemID       int32            `json:"problemId"`
	SubmittedCode   string           `json:"submittedCode"`
	SubmittedStdin  pgtype.Text      `json:"submittedStdin"`
	FailedTestCase  []byte           `json:"failedTestCase"`
	PassedTestCases int32            `json:"passedTestCases"`
	TotalTestCases  int32            `json:"totalTestCases"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.ID,
		arg.Stdout,
		arg.Time,
		arg.Memory,
		arg.Stderr,
		arg.CompileOutput,
		arg.Message,
		arg.Status,
		arg.LanguageID,
		arg.LanguageName,
		arg.AccountID,
		arg.ProblemID,
		arg.SubmittedCode,
		arg.SubmittedStdin,
		arg.FailedTestCase,
		arg.PassedTestCases,
		arg.TotalTestCases,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Stdout,
		&i.Time,
		&i.Memory,
		&i.Stderr,
		&i.CompileOutput,
		&i.Message,
		&i.Status,
		&i.LanguageID,
		&i.LanguageName,
		&i.CreatedAt,
		&i.AccountID,
		&i.SubmittedCode,
		&i.SubmittedStdin,
		&i.FailedTestCase,
		&i.PassedTestCases,
		&i.TotalTestCases,
		&i.ProblemID,
	)
	return i, err
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT 
    id, stdout, time, memory, stderr, compile_output, message, status, language_id, language_name, created_at, account_id, submitted_code, submitted_stdin, failed_test_case, passed_test_cases, total_test_cases, problem_id,
    CASE WHEN EXISTS (SELECT 1 FROM starred_submission WHERE submission_id = s.id AND starred_submission.user_id = $2) THEN true ELSE false END AS starred
FROM submission s
WHERE s.id = $1
`

type GetSubmissionByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"userId"`
}

type GetSubmissionByIDRow struct {
	ID              pgtype.UUID      `json:"id"`
	Stdout          pgtype.Text      `json:"stdout"`
	Time            pgtype.Text      `json:"time"`
	Memory          pgtype.Int4      `json:"memory"`
	Stderr          pgtype.Text      `json:"stderr"`
	CompileOutput   pgtype.Text      `json:"compileOutput"`
	Message         pgtype.Text      `json:"message"`
	Status          SubmissionStatus `json:"status"`
	LanguageID      int32            `json:"languageId"`
	LanguageName    string           `json:"languageName"`
	CreatedAt       pgtype.Timestamp `json:"createdAt"`
	AccountID       string           `json:"accountId"`
	SubmittedCode   string           `json:"submittedCode"`
	SubmittedStdin  pgtype.Text      `json:"submittedStdin"`
	FailedTestCase  []byte           `json:"failedTestCase"`
	PassedTestCases pgtype.Int4      `json:"passedTestCases"`
	TotalTestCases  pgtype.Int4      `json:"totalTestCases"`
	ProblemID       int32            `json:"problemId"`
	Starred         bool             `json:"starred"`
}

func (q *Queries) GetSubmissionByID(ctx context.Context, arg GetSubmissionByIDParams) (GetSubmissionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSubmissionByID, arg.ID, arg.UserID)
	var i GetSubmissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Stdout,
		&i.Time,
		&i.Memory,
		&i.Stderr,
		&i.CompileOutput,
		&i.Message,
		&i.Status,
		&i.LanguageID,
		&i.LanguageName,
		&i.CreatedAt,
		&i.AccountID,
		&i.SubmittedCode,
		&i.SubmittedStdin,
		&i.FailedTestCase,
		&i.PassedTestCases,
		&i.TotalTestCases,
		&i.ProblemID,
		&i.Starred,
	)
	return i, err
}

const getSubmissionsByID = `-- name: GetSubmissionsByID :many
SELECT id, stdout, time, memory, stderr, compile_output, message, status, language_id, language_name, created_at, account_id, submitted_code, submitted_stdin, failed_test_case, passed_test_cases, total_test_cases, problem_id FROM submission WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetSubmissionsByID(ctx context.Context, ids []pgtype.UUID) ([]Submission, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByID, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submission
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Stdout,
			&i.Time,
			&i.Memory,
			&i.Stderr,
			&i.CompileOutput,
			&i.Message,
			&i.Status,
			&i.LanguageID,
			&i.LanguageName,
			&i.CreatedAt,
			&i.AccountID,
			&i.SubmittedCode,
			&i.SubmittedStdin,
			&i.FailedTestCase,
			&i.PassedTestCases,
			&i.TotalTestCases,
			&i.ProblemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByProblemID = `-- name: GetSubmissionsByProblemID :many
SELECT id, stdout, time, memory, stderr, compile_output, message, status, language_id, language_name, created_at, account_id, submitted_code, submitted_stdin, failed_test_case, passed_test_cases, total_test_cases, problem_id FROM submission WHERE problem_id = $1
`

func (q *Queries) GetSubmissionsByProblemID(ctx context.Context, problemID int32) ([]Submission, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByProblemID, problemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Submission
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Stdout,
			&i.Time,
			&i.Memory,
			&i.Stderr,
			&i.CompileOutput,
			&i.Message,
			&i.Status,
			&i.LanguageID,
			&i.LanguageName,
			&i.CreatedAt,
			&i.AccountID,
			&i.SubmittedCode,
			&i.SubmittedStdin,
			&i.FailedTestCase,
			&i.PassedTestCases,
			&i.TotalTestCases,
			&i.ProblemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByUsername = `-- name: GetSubmissionsByUsername :many
WITH user_submissions AS (
    SELECT
        s.id                AS submission_id,
        s.stdout,
        s.time,
        s.memory,
        s.stderr,
        s.compile_output,
        s.message,
        s.status,
        s.language_id,
        s.language_name,
        s.account_id,
        s.submitted_code,
        s.submitted_stdin,
        s.failed_test_case,
        s.passed_test_cases,
        s.total_test_cases,
        s.problem_id,
        s.created_at,
        p.title             AS problem_title,
        p.description       AS problem_description,
        p.difficulty        AS problem_difficulty,
        p.points            AS problem_points,
        a.username,
        CASE WHEN EXISTS (SELECT 1 FROM starred_submission WHERE submission_id = s.id AND starred_submission.user_id = $3::text) THEN true ELSE false END AS starred
    FROM submission s
    JOIN account a
        ON s.account_id = a.id
    JOIN problem p
        ON s.problem_id = p.id
    WHERE
        a.username = $4
        -- Filter by problem_id only if not 0
        AND (
            $5 = 0
            OR s.problem_id = $5
        )
        -- Filter by status only if not empty string
        AND (
            $6 = ''
            OR s.status = $6::submission_status
        )
)
SELECT
    submission_id                  AS id,
    stdout,
    time,
    memory,
    stderr,
    compile_output,
    message,
    status,
    language_id,
    language_name,
    account_id,
    submitted_code,
    submitted_stdin,
    problem_id,
    created_at,
    problem_title,
    problem_description,
    problem_difficulty,
    problem_points,
    username,
    starred,
    failed_test_case,
    passed_test_cases,
    total_test_cases
FROM user_submissions
ORDER BY
    -- 1) Sort by 'time' (the "time" column cast to float)
    CASE
        WHEN $1 = 'time' AND $2 = 'ASC'
            THEN time 
    END ASC,
    CASE
        WHEN $1 = 'time' AND $2 = 'DESC'
            THEN time 
    END DESC,

    -- 2) Sort by 'memory'
    CASE
        WHEN $1 = 'memory' AND $2 = 'ASC'
            THEN memory
    END ASC,
    CASE
        WHEN $1 = 'memory' AND $2 = 'DESC'
            THEN memory
    END DESC,

    -- 3) Sort by 'created'
    CASE
        WHEN $1 = 'created_at' AND $2 = 'ASC'
            THEN created_at
    END ASC,
    CASE
        WHEN $1 = 'created_at' AND $2 = 'DESC'
            THEN created_at
    END DESC,

    -- 4) Sort by 'status' (alphabetical)
    CASE
        WHEN $1 = 'status' AND $2 = 'ASC'
            THEN status
    END ASC,
    CASE
        WHEN $1 = 'status' AND $2 = 'DESC'
            THEN status
    END DESC,

    -- 5) Fallback ordering for stability
    submission_id DESC
NULLS LAST
`

type GetSubmissionsByUsernameParams struct {
	Sort          interface{} `json:"sort"`
	SortDirection interface{} `json:"sortDirection"`
	UserID        string      `json:"userId"`
	Username      string      `json:"username"`
	ProblemID     interface{} `json:"problemId"`
	Status        interface{} `json:"status"`
}

type GetSubmissionsByUsernameRow struct {
	ID                 pgtype.UUID       `json:"id"`
	Stdout             pgtype.Text       `json:"stdout"`
	Time               pgtype.Text       `json:"time"`
	Memory             pgtype.Int4       `json:"memory"`
	Stderr             pgtype.Text       `json:"stderr"`
	CompileOutput      pgtype.Text       `json:"compileOutput"`
	Message            pgtype.Text       `json:"message"`
	Status             SubmissionStatus  `json:"status"`
	LanguageID         int32             `json:"languageId"`
	LanguageName       string            `json:"languageName"`
	AccountID          string            `json:"accountId"`
	SubmittedCode      string            `json:"submittedCode"`
	SubmittedStdin     pgtype.Text       `json:"submittedStdin"`
	ProblemID          int32             `json:"problemId"`
	CreatedAt          pgtype.Timestamp  `json:"createdAt"`
	ProblemTitle       string            `json:"problemTitle"`
	ProblemDescription pgtype.Text       `json:"problemDescription"`
	ProblemDifficulty  ProblemDifficulty `json:"problemDifficulty"`
	ProblemPoints      int32             `json:"problemPoints"`
	Username           string            `json:"username"`
	Starred            bool              `json:"starred"`
	FailedTestCase     []byte            `json:"failedTestCase"`
	PassedTestCases    pgtype.Int4       `json:"passedTestCases"`
	TotalTestCases     pgtype.Int4       `json:"totalTestCases"`
}

func (q *Queries) GetSubmissionsByUsername(ctx context.Context, arg GetSubmissionsByUsernameParams) ([]GetSubmissionsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByUsername,
		arg.Sort,
		arg.SortDirection,
		arg.UserID,
		arg.Username,
		arg.ProblemID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByUsernameRow
	for rows.Next() {
		var i GetSubmissionsByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Stdout,
			&i.Time,
			&i.Memory,
			&i.Stderr,
			&i.CompileOutput,
			&i.Message,
			&i.Status,
			&i.LanguageID,
			&i.LanguageName,
			&i.AccountID,
			&i.SubmittedCode,
			&i.SubmittedStdin,
			&i.ProblemID,
			&i.CreatedAt,
			&i.ProblemTitle,
			&i.ProblemDescription,
			&i.ProblemDifficulty,
			&i.ProblemPoints,
			&i.Username,
			&i.Starred,
			&i.FailedTestCase,
			&i.PassedTestCases,
			&i.TotalTestCases,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
